<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta http-equiv="Content-Security-Policy" content="frame-ancestors *;">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garbiczland Planner</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-color: #ffffff;
        }
        
        .color-swatch {
            width: 25px;
            height: 25px;
            display: inline-block;
            border: 1px solid #333;
            vertical-align: middle;
            margin-right: 10px;
        }
        
        .zone-item {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
        }
        
        .zone-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .zone-item.selected {
            background-color: rgba(0,0,0,0.1);
            font-weight: bold;
        }
        
        .deactivated {
            opacity: 0.5;
            text-decoration: line-through;
        }
        
        #main-canvas {
            cursor: crosshair;
            border: 1px solid #ddd;
            background-color: #ffffff;
        }
        
        .tool-button {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .tool-button:hover {
            background-color: #e0e0e0;
        }
        
        .tool-button i {
            margin-right: 5px;
        }
        
        .sidebar {
            height: calc(100vh - 60px);
            overflow-y: auto;
            padding: 15px;
            background-color: #ffffff;
            border: 1px solid #eaeaea;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 16px;
            width: 95%;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.18);
            transition: all 0.3s cubic-bezier(.4,0,.2,1);
            animation: modal-fade-in 0.3s;
        }
        @media (max-width: 640px) {
            .modal-content {
                max-width: 100vw;
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                padding: 16px 8px;
                overflow-y: auto;
            }
        }
        @keyframes modal-fade-in {
            from { opacity: 0; transform: translateY(40px);}
            to { opacity: 1; transform: translateY(0);}
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-close {
            cursor: pointer;
            font-size: 20px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .zone-controls {
            display: flex;
            justify-content: flex-end;
            gap: 5px;
        }
        
        .zone-control {
            cursor: pointer;
            padding: 3px;
            color: #666;
        }
        
        .zone-control:hover {
            color: #000;
        }
        
        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .scenario-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .scenario-item:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eaeaea;
        }
    </style>
</head>
<body>
    <div class="flex flex-col h-screen">
        <!-- Header Controls -->
        <header class="bg-white shadow-sm p-3 flex items-center justify-between">
            <div class="flex items-center">
                <!-- Hamburger menu for mobile -->
                <button id="sidebar-toggle-btn" class="md:hidden mr-3 p-2 rounded hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="Toggle sidebars">
                    <i class="fas fa-bars text-xl"></i>
                </button>
                <div class="text-xl font-bold text-gray-800">Garbiczland Planner</div>
            </div>
            <div class="flex items-center">
                <div class="mr-4 flex items-center">
                    <button id="import-version-btn" class="tool-button mr-2">
                        <i class="fas fa-file-import"></i> Import Version
                    </button>
                    <button id="save-version-btn" class="tool-button mr-2">
                        <i class="fas fa-save"></i> Save Version
                    </button>
                    <span class="text-sm text-gray-600 mr-2">Mode:</span>
                </div>
                <button id="upload-bg-btn" class="tool-button">
                    <i class="fas fa-image"></i> Upload Background
                </button>
                <button id="download-png-btn" class="tool-button">
                    <i class="fas fa-download"></i> Download as PNG
                </button>
            </div>
        </header>
        
        <!-- Main Content Area -->
        <div class="flex flex-1 overflow-hidden flex-col md:flex-row">
            <!-- Left Sidebar - Scenarios and Zone Items -->
            <div id="left-sidebar" class="sidebar bg-white shadow-sm w-full md:w-1/4 border-b md:border-b-0 md:border-r border-gray-200 order-1 md:order-none transition-transform duration-300 ease-in-out transform md:translate-x-0 -translate-x-full md:block fixed md:static top-16 left-0 z-30 h-[calc(100vh-64px)] md:h-auto overflow-y-auto">
                <!-- Scenarios Section -->
                <h2 class="section-title">Scenarios</h2>
                <button id="add-scenario-btn" class="tool-button mb-4 w-full">
                    <i class="fas fa-plus"></i> Add New Scenario
                </button>
                <div id="scenarios-container" class="space-y-2 mb-6"></div>
                
                <!-- Zones Section -->
                <h2 class="section-title mt-6">Zones</h2>
                <button id="add-zone-btn" class="tool-button mb-4 w-full">
                    <i class="fas fa-plus"></i> Add New Zone Item
                </button>
                <div id="zone-container" class="space-y-2"></div>
                <div class="text-xs text-gray-500 mt-4">
                    <p>Click on a zone to select it for drawing</p>
                </div>
            </div>
            
            <!-- Main Canvas Area -->
            <div class="flex-1 flex justify-center items-center bg-gray-50 p-2 sm:p-4 overflow-auto order-3 md:order-none">
                <div class="flex items-center justify-center">
                    <canvas id="main-canvas" class="rounded shadow" style="background: #fff;"></canvas>
                </div>
            </div>
            
            <!-- Right Sidebar - Controls -->
            <div id="right-sidebar" class="sidebar bg-white shadow-sm w-full md:w-1/4 border-t md:border-t-0 md:border-l border-gray-200 order-2 md:order-none transition-transform duration-300 ease-in-out transform md:translate-x-0 translate-x-full md:block fixed md:static top-16 right-0 z-30 h-[calc(100vh-64px)] md:h-auto overflow-y-auto">
                <h3 class="section-title">Controls</h3>
                <button id="undo-btn" class="tool-button mb-2 w-full">
                    <i class="fas fa-undo"></i> Undo (Ctrl+Z)
                </button>
                <div class="text-xs text-gray-500 mt-4 mb-6">
                    <p>• Click on the map to add points</p>
                    <p>• Press Enter to complete a shape</p>
                    <p>• Click and drag to move shapes</p>
                    <p>• Right-click on points to delete them</p>
                    <p>• Right-click on lines to add points</p>
                </div>
                
                <!-- Saved Versions Section -->
                <h3 class="section-title mt-6">Saved Versions</h3>
                <div id="versions-container" class="space-y-2"></div>
            </div>
        </div>
    </div>
    
    <!-- Add/Edit Zone Item Modal -->
    <div id="zone-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title" class="text-lg font-semibold">Add Zone Item</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="input-group">
                <label for="zone-name">Name:</label>
                <input type="text" id="zone-name" placeholder="Enter zone item name">
            </div>
            <div class="input-group">
                <label for="zone-color">Color:</label>
                <input type="color" id="zone-color">
                <div class="help-text">The system will ensure this color is unique</div>
            </div>
            <div class="input-group">
                <label>Active in Scenarios:</label>
                <div id="scenario-checkboxes" class="mt-2 space-y-2"></div>
                <div class="help-text">Select which scenarios this zone should appear in</div>
            </div>
            <div class="flex justify-end mt-4">
                <button id="cancel-zone-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                <button id="save-zone-btn" class="tool-button bg-blue-500 hover:bg-blue-600">Save</button>
            </div>
        </div>
    </div>
    
        <!-- Add/Edit Scenario Modal -->
        <div id="scenario-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="scenario-modal-title" class="text-lg font-semibold">Add Scenario</h3>
                    <span class="modal-close-scenario" style="cursor:pointer;">&times;</span>
                </div>
                <div class="input-group">
                    <label for="scenario-name">Name:</label>
                    <input type="text" id="scenario-name" placeholder="Enter scenario name">
                </div>
                <div class="input-group">
                    <label for="scenario-description">Description:</label>
                    <input type="text" id="scenario-description" placeholder="Enter scenario description">
                </div>
                <div class="input-group">
                    <label for="scenario-active">
                        <input type="checkbox" id="scenario-active" class="mr-2">
                        Set as active scenario
                    </label>
                </div>
                <div class="flex justify-end mt-4">
                    <button id="cancel-scenario-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                    <button id="save-scenario-btn" class="tool-button bg-blue-500 hover:bg-blue-600">Save</button>
                </div>
            </div>
        </div>

        <!-- Rename Version Modal -->
        <div id="version-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="version-modal-title" class="text-lg font-semibold">Rename Version</h3>
                    <span class="modal-close-version" style="cursor:pointer;">&times;</span>
                </div>
                <div class="input-group">
                    <label for="version-name">Name:</label>
                    <input type="text" id="version-name" placeholder="Enter version name">
                </div>
                <div class="flex justify-end mt-4">
                    <button id="cancel-version-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                    <button id="save-version-name-btn" class="tool-button bg-blue-500 hover:bg-blue-600">Save</button>
                </div>
            </div>
        </div>

        <!-- Save New Version Modal -->
        <div id="save-new-version-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="text-lg font-semibold">Save New Version</h3>
                    <span class="modal-close-save-version" style="cursor:pointer;">&times;</span>
                </div>
                <div class="input-group">
                    <label for="new-version-name">Version Name:</label>
                    <input type="text" id="new-version-name" placeholder="Enter a name for this version">
                </div>
                <div class="flex justify-end mt-4">
                    <button id="cancel-save-new-version-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                    <button id="confirm-save-new-version-btn" class="tool-button bg-blue-500 hover:bg-blue-600">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Import Version Modal -->
        <div id="import-version-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="text-lg font-semibold">Import Version</h3>
                    <span class="modal-close-import-version" style="cursor:pointer;">&times;</span>
                </div>
                <div class="input-group">
                    <label for="import-version-data">Version Data or Deeplink:</label>
                    <textarea id="import-version-data" placeholder="Paste version data or deeplink here" rows="5" class="w-full p-2 border border-gray-300 rounded"></textarea>
                </div>
                <div class="flex justify-end mt-4">
                    <button id="cancel-import-version-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                    <button id="confirm-import-version-btn" class="tool-button bg-blue-500 hover:bg-blue-600">Import</button>
                </div>
            </div>
        </div>

    <script>
        // Main application state
        const appState = {
            zoneItems: [],
            scenarios: [],
            currentZoneItem: null,
            currentScenario: null,  // Track the currently selected scenario
            currentShape: [],
            currentVersion: null, // Track the currently loaded version
            shapes: [],
            selectedShape: null,
            selectedPoint: null,
            isDragging: false,
            dragStartPos: { x: 0, y: 0 },
            undoStack: [],
            backgroundImage: null,
            editingItemId: null,
            configLoaded: false,  // Track if config has been loaded
            versions: [],
            deleteButtonPosition: null, // Store position of delete button for hit testing
            
            // Zoom and pan state
            zoomLevel: 1,
            panOffset: { x: 0, y: 0 },
            isPanning: false,
            lastMousePos: { x: 0, y: 0 },
            
            colorPalette: [
                '#FFFFAA', '#FFFF00', '#B2B200', '#FFA500', '#000000',
                '#FF0000', '#FF66FF', '#0000FF', '#00FF00', '#800080',
                '#008000', '#808000', '#800000', '#00FFFF', '#FFC0CB',
                '#A52A2A', '#808080', '#4B0082', '#FFD700', '#7FFFD4'
            ],
            usedColors: []
        };
        
        // DOM Elements
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const zoneContainer = document.getElementById('zone-container');
        const scenariosContainer = document.getElementById('scenarios-container');
        const uploadBgBtn = document.getElementById('upload-bg-btn');
        const importVersionBtn = document.getElementById('import-version-btn');
        const downloadPngBtn = document.getElementById('download-png-btn');
        const undoBtn = document.getElementById('undo-btn');
        const editShapesBtn = document.getElementById('edit-shapes-btn');
        const addZoneBtn = document.getElementById('add-zone-btn');
        const zoneModal = document.getElementById('zone-modal');
        const modalTitle = document.getElementById('modal-title');
        const zoneNameInput = document.getElementById('zone-name');
        const zoneColorInput = document.getElementById('zone-color');
        const saveZoneBtn = document.getElementById('save-zone-btn');
        const cancelZoneBtn = document.getElementById('cancel-zone-btn');
        const modalClose = document.querySelector('.modal-close');
        // Scenario modal elements
        const addScenarioBtn = document.getElementById('add-scenario-btn');
        const scenarioModal = document.getElementById('scenario-modal');
        const scenarioModalTitle = document.getElementById('scenario-modal-title');
        const scenarioNameInput = document.getElementById('scenario-name');
        const scenarioDescriptionInput = document.getElementById('scenario-description');
        const scenarioActiveInput = document.getElementById('scenario-active');
        const saveScenarioBtn = document.getElementById('save-scenario-btn');
        const cancelScenarioBtn = document.getElementById('cancel-scenario-btn');
        const modalCloseScenario = document.querySelector('.modal-close-scenario');
        const versionsContainer = document.getElementById('versions-container');
        
        // Version modal elements
        const versionModal = document.getElementById('version-modal');
        const versionModalTitle = document.getElementById('version-modal-title');
        const versionNameInput = document.getElementById('version-name');
        const saveVersionNameBtn = document.getElementById('save-version-name-btn');
        const cancelVersionBtn = document.getElementById('cancel-version-btn');
        const modalCloseVersion = document.querySelector('.modal-close-version');
        
        // Save new version modal elements
        const saveNewVersionModal = document.getElementById('save-new-version-modal');
        const newVersionNameInput = document.getElementById('new-version-name');
        const confirmSaveNewVersionBtn = document.getElementById('confirm-save-new-version-btn');
        const cancelSaveNewVersionBtn = document.getElementById('cancel-save-new-version-btn');
        const modalCloseSaveVersion = document.querySelector('.modal-close-save-version');
        
        // Import version modal elements
        const importVersionModal = document.getElementById('import-version-modal');
        const importVersionDataInput = document.getElementById('import-version-data');
        const confirmImportVersionBtn = document.getElementById('confirm-import-version-btn');
        const cancelImportVersionBtn = document.getElementById('cancel-import-version-btn');
        const modalCloseImportVersion = document.querySelector('.modal-close-import-version');
        
        // Load configuration from config.json
        async function loadConfiguration() {
            try {
                // Try to load the embedded config first
                const embeddedConfig = {
                    "backgroundImage": "garbiczland.png",
                    "zones": [
                        {
                            "id": "zone_1",
                            "name": "Member 1 (Hellgelb)",
                            "color": "#FFFFAA",
                            "active": true,
                            "activeInScenarios": ["festival", "member1"]
                        },
                        {
                            "id": "zone_2",
                            "name": "Member 2 (Gelb)",
                            "color": "#FFFF00",
                            "active": true,
                            "activeInScenarios": ["festival", "member2"]
                        },
                        {
                            "id": "zone_3",
                            "name": "Member 3 (Dunkel Gelb)",
                            "color": "#B2B200",
                            "active": true,
                            "activeInScenarios": ["festival", "member3"]
                        },
                        {
                            "id": "zone_4",
                            "name": "Shareholder (Orange)",
                            "color": "#FFA500",
                            "active": true,
                            "activeInScenarios": ["festival", "all_year"]
                        },
                        {
                            "id": "zone_5",
                            "name": "Backstage (Schwarz)",
                            "color": "#000000",
                            "active": true,
                            "activeInScenarios": ["festival", "all_year", "other_events"]
                        },
                        {
                            "id": "zone_6",
                            "name": "Event (Rot)",
                            "color": "#FF0000",
                            "active": true,
                            "activeInScenarios": ["festival", "other_events"]
                        },
                        {
                            "id": "zone_7",
                            "name": "Camping (Pink)",
                            "color": "#FF66FF",
                            "active": true,
                            "activeInScenarios": ["festival"]
                        },
                        {
                            "id": "zone_8",
                            "name": "Spa (Blau)",
                            "color": "#0000FF",
                            "active": true,
                            "activeInScenarios": ["all_year"]
                        }
                    ],
                    "scenarios": [
                        {
                            "id": "festival",
                            "name": "Festival",
                            "description": "Main festival layout",
                            "active": true
                        },
                        {
                            "id": "all_year",
                            "name": "All Year",
                            "description": "Year-round access areas",
                            "active": false
                        },
                        {
                            "id": "member1",
                            "name": "Member 1",
                            "description": "Member 1 specific areas",
                            "active": false
                        },
                        {
                            "id": "member2",
                            "name": "Member 2",
                            "description": "Member 2 specific areas",
                            "active": false
                        },
                        {
                            "id": "member3",
                            "name": "Member 3",
                            "description": "Member 3 specific areas",
                            "active": false
                        },
                        {
                            "id": "other_events",
                            "name": "Other Events",
                            "description": "Layout for other events",
                            "active": false
                        }
                    ]
                };
                
                // Try to load the external config file (may fail due to CORS when running from file://)
                try {
                    const response = await fetch('config.json');
                    if (response.ok) {
                        const config = await response.json();
                        console.log('Loaded external config.json');
                        
                        // Load background image
                        if (config.backgroundImage) {
                            loadBackgroundImage(config.backgroundImage);
                        }
                        
                        // Set configLoaded flag
                        appState.configLoaded = true;
                        
                        return config;
                    }
                } catch (fetchError) {
                    console.warn('Could not load external config.json, using embedded config:', fetchError);
                }
                
                // If external config failed, use the embedded config
                console.log('Using embedded config');
                
                // Load background image
                if (embeddedConfig.backgroundImage) {
                    loadBackgroundImage(embeddedConfig.backgroundImage);
                }
                
                // Set configLoaded flag
                appState.configLoaded = true;
                
                return embeddedConfig;
            } catch (error) {
                console.error('Error loading configuration:', error);
                return null;
            }
        }
        
        // Helper function to load background image
        function loadBackgroundImage(src) {
            const img = new Image();
            img.onload = function() {
                appState.backgroundImage = img;
                // Set canvas size to match image dimensions
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                redrawCanvas();
                // Enable download button after image is loaded
                downloadPngBtn.disabled = false;
                downloadPngBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            };
            img.src = src;
        }
        
        // Initialize zone items from config
        function initializeDefaultZoneItems(config) {
            if (config && config.zones && config.zones.length > 0) {
                config.zones.forEach(item => {
                    const zoneItem = {
                        id: item.id || generateId(),
                        name: item.name,
                        color: item.color,
                        active: item.active !== undefined ? item.active : true,
                        activeInScenarios: item.activeInScenarios || []
                    };
                    
                    appState.zoneItems.push(zoneItem);
                    appState.usedColors.push(item.color);
                });
            } else {
                // Fallback to hardcoded defaults if config is not available
                const defaultItems = [
                    { id: generateId(), name: 'Member 1 (Hellgelb)', color: '#FFFFAA', active: true, activeInScenarios: ['festival', 'member1'] },
                    { id: generateId(), name: 'Member 2 (Gelb)', color: '#FFFF00', active: true, activeInScenarios: ['festival', 'member2'] },
                    { id: generateId(), name: 'Member 3 (Dunkel Gelb)', color: '#B2B200', active: true, activeInScenarios: ['festival', 'member3'] },
                    { id: generateId(), name: 'Shareholder (Orange)', color: '#FFA500', active: true, activeInScenarios: ['festival', 'all_year'] },
                    { id: generateId(), name: 'Backstage (Schwarz)', color: '#000000', active: true, activeInScenarios: ['festival', 'all_year', 'other_events'] },
                    { id: generateId(), name: 'Event (Rot)', color: '#FF0000', active: true, activeInScenarios: ['festival', 'other_events'] },
                    { id: generateId(), name: 'Camping (Pink)', color: '#FF66FF', active: true, activeInScenarios: ['festival'] },
                    { id: generateId(), name: 'Spa (Blau)', color: '#0000FF', active: true, activeInScenarios: ['all_year'] }
                ];
                
                defaultItems.forEach(item => {
                    appState.zoneItems.push(item);
                    appState.usedColors.push(item.color);
                });
            }
        }

        // Initialize scenarios from config
        function initializeDefaultScenarios(config) {
            if (config && config.scenarios && config.scenarios.length > 0) {
                config.scenarios.forEach(item => {
                    const scenario = {
                        id: item.id || generateId(),
                        name: item.name,
                        description: item.description || '',
                        active: item.active !== undefined ? item.active : false,
                        zones: {}
                    };
                    
                    // Initialize zones visibility
                    appState.zoneItems.forEach(zone => {
                        scenario.zones[zone.id] = {
                            visible: zone.activeInScenarios.includes(scenario.id)
                        };
                    });
                    
                    appState.scenarios.push(scenario);
                    
                    // Set the first active scenario as current
                    if (item.active && !appState.currentScenario) {
                        appState.currentScenario = scenario.id;
                    }
                });
                
                // If no scenario is active, set the first one as active
                if (!appState.currentScenario && appState.scenarios.length > 0) {
                    appState.currentScenario = appState.scenarios[0].id;
                    appState.scenarios[0].active = true;
                }
            } else {
                // Fallback to hardcoded defaults if config is not available
                const defaultScenarios = [
                    { id: 'festival', name: 'Festival', description: 'Main festival layout', active: true },
                    { id: 'all_year', name: 'All Year', description: 'Year-round access areas', active: false },
                    { id: 'member1', name: 'Member 1', description: 'Member 1 specific areas', active: false },
                    { id: 'member2', name: 'Member 2', description: 'Member 2 specific areas', active: false },
                    { id: 'member3', name: 'Member 3', description: 'Member 3 specific areas', active: false },
                    { id: 'other_events', name: 'Other Events', description: 'Layout for other events', active: false }
                ];

                defaultScenarios.forEach(scenario => {
                    const newScenario = { ...scenario, zones: {} };
                    
                    // Initialize zones visibility based on activeInScenarios
                    appState.zoneItems.forEach(zone => {
                        newScenario.zones[zone.id] = {
                            visible: zone.activeInScenarios.includes(scenario.id)
                        };
                    });
                    
                    appState.scenarios.push(newScenario);
                });
                
                // Set the first scenario as current if none is set
                if (!appState.currentScenario && appState.scenarios.length > 0) {
                    appState.currentScenario = appState.scenarios[0].id;
                }
            }
        }
        
        // Generate a unique ID
        function generateId() {
            return 'id_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Get a unique color for new zone items
        function getUniqueColor() {
            const availableColors = appState.colorPalette.filter(
                color => !appState.usedColors.includes(color)
            );
            
            if (availableColors.length > 0) {
                return availableColors[0];
            } else {
                const r = Math.floor(Math.random() * 200) + 55;
                const g = Math.floor(Math.random() * 200) + 55;
                const b = Math.floor(Math.random() * 200) + 55;
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
        }
        
        // Render zone items in the sidebar
        function renderZoneItems() {
            zoneContainer.innerHTML = '';
            
            // Get current scenario
            const currentScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
            if (!currentScenario) return;
            
            // Filter zones to show only those active in the current scenario
            appState.zoneItems.forEach(item => {
                // Skip zones not active in the current scenario
                if (!item.activeInScenarios.includes(currentScenario.id)) return;
                
                const zoneItem = document.createElement('div');
                zoneItem.className = `zone-item ${appState.currentZoneItem === item.id ? 'selected' : ''} ${!item.active ? 'deactivated' : ''}`;
                zoneItem.dataset.id = item.id;
                
                const leftSide = document.createElement('div');
                leftSide.className = 'flex items-center flex-1';
                
                const colorSwatch = document.createElement('span');
                colorSwatch.className = 'color-swatch';
                colorSwatch.style.backgroundColor = item.color;
                colorSwatch.style.opacity = item.active ? '1' : '0.5';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = item.name;
                
                leftSide.appendChild(colorSwatch);
                leftSide.appendChild(nameSpan);
                
                const controls = document.createElement('div');
                controls.className = 'zone-controls';
                
                const editBtn = document.createElement('span');
                editBtn.className = 'zone-control';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.title = 'Edit';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    openEditZoneModal(item);
                };
                
                const toggleBtn = document.createElement('span');
                toggleBtn.className = 'zone-control';
                toggleBtn.innerHTML = item.active ? '<i class="fas fa-eye-slash"></i>' : '<i class="fas fa-eye"></i>';
                toggleBtn.title = item.active ? 'Deactivate' : 'Activate';
                toggleBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleZoneItem(item.id);
                };
                
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'zone-control';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteZoneItem(item.id);
                };
                
                controls.appendChild(editBtn);
                controls.appendChild(toggleBtn);
                controls.appendChild(deleteBtn);
                
                zoneItem.appendChild(leftSide);
                zoneItem.appendChild(controls);
                
                zoneItem.addEventListener('click', () => {
                    if (item.active) {
                        setCurrentZoneItem(item.id);
                    }
                });
                
                zoneContainer.appendChild(zoneItem);
            });
        }
        
        // Render scenario controls
        function renderScenarios() {
            scenariosContainer.innerHTML = '';
            
            // Create header for scenario selection
            let scenarioHeader = document.createElement('div');
            scenarioHeader.className = 'mb-4';
            scenarioHeader.innerHTML = '<p class="text-sm text-gray-600 mb-2">Select active scenario:</p>';
            scenariosContainer.appendChild(scenarioHeader);
            
            appState.scenarios.forEach(scenario => {
                const scenarioItem = document.createElement('div');
                const isActive = scenario.id === appState.currentScenario;
                
                scenarioItem.className = `scenario-item ${isActive ? 'bg-blue-100 font-semibold' : ''}`;
                scenarioItem.dataset.id = scenario.id;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = scenario.name;
                
                const controls = document.createElement('div');
                controls.className = 'flex items-center';
                
                const toggleBtn = document.createElement('button');
                toggleBtn.innerHTML = '<i class="fas fa-eye"></i>';
                toggleBtn.className = 'zone-control mr-2';
                toggleBtn.title = 'Toggle Visibility';
                toggleBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleScenarioVisibility(scenario.id);
                };

                // Edit button
                const editBtn = document.createElement('span');
                editBtn.className = 'zone-control mr-2';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.title = 'Edit Scenario';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    openEditScenarioModal(scenario);
                };

                // Delete button
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'zone-control';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete Scenario';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteScenario(scenario.id);
                };

                controls.appendChild(toggleBtn);
                controls.appendChild(editBtn);
                controls.appendChild(deleteBtn);

                scenarioItem.appendChild(nameSpan);
                scenarioItem.appendChild(controls);

                // Add click handler to select this scenario
                scenarioItem.addEventListener('click', () => {
                    setCurrentScenario(scenario.id);
                });

                scenariosContainer.appendChild(scenarioItem);
            });
            
            // Add description for the current scenario
            const currentScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
            if (currentScenario && currentScenario.description) {
                const descriptionEl = document.createElement('div');
                descriptionEl.className = 'mt-4 text-sm text-gray-600';
                descriptionEl.textContent = currentScenario.description;
                scenariosContainer.appendChild(descriptionEl);
            }
        }
        
        // Render saved versions
        function renderVersions() {
            versionsContainer.innerHTML = '';
            
            // Add a "Save Current Version" button at the top
            if (appState.currentVersion !== null) {
                const saveCurrentBtn = document.createElement('button');
                saveCurrentBtn.className = 'tool-button mb-4 w-full';
                saveCurrentBtn.innerHTML = '<i class="fas fa-save"></i> Save Current Version';
                saveCurrentBtn.title = 'Save changes to the current version';
                saveCurrentBtn.onclick = () => saveCurrentVersion();
                versionsContainer.appendChild(saveCurrentBtn);
            }
            
            if(appState.versions.length > 0){
                appState.versions.forEach(version => {
                    const versionItem = document.createElement('div');
                    // Highlight the current version
                    const isCurrentVersion = version.timestamp === appState.currentVersion;
                    versionItem.className = `scenario-item ${isCurrentVersion ? 'bg-blue-100 font-semibold' : ''}`;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = version.versionName;
                    
                    const controls = document.createElement('div');
                    controls.className = 'flex items-center';
                    
                    // Load button (don't show for current version)
                    if (!isCurrentVersion) {
                        const loadBtn = document.createElement('button');
                        loadBtn.innerHTML = '<i class="fas fa-upload"></i>';
                        loadBtn.className = 'zone-control mr-2';
                        loadBtn.title = 'Load Version';
                        loadBtn.onclick = (e) => {
                            e.stopPropagation();
                            loadVersion(version);
                        };
                        controls.appendChild(loadBtn);
                    }
                    
                    // Edit name button
                    const editBtn = document.createElement('button');
                    editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                    editBtn.className = 'zone-control mr-2';
                    editBtn.title = 'Rename Version';
                    editBtn.onclick = (e) => {
                        e.stopPropagation();
                        renameVersion(version);
                    };
                    
                    // Share button
                    const shareBtn = document.createElement('button');
                    shareBtn.innerHTML = '<i class="fas fa-share-alt"></i>';
                    shareBtn.className = 'zone-control mr-2';
                    shareBtn.title = 'Share Version';
                    shareBtn.onclick = (e) => {
                        e.stopPropagation();
                        shareVersion(version);
                    };
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.className = 'zone-control mr-2';
                    deleteBtn.title = 'Delete Version';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteVersion(version);
                    };
                    
                    controls.appendChild(editBtn);
                    controls.appendChild(shareBtn);
                    controls.appendChild(deleteBtn);
                    versionItem.appendChild(nameSpan);
                    versionItem.appendChild(controls);
                    versionsContainer.appendChild(versionItem);
                });
            } else {
                const noVersionsMsg = document.createElement('div');
                noVersionsMsg.className = 'text-sm text-gray-600';
                noVersionsMsg.textContent = 'No saved versions yet. Use the "Save Version" button to create one.';
                versionsContainer.appendChild(noVersionsMsg);
            }
        }
        
        // Set current zone item for drawing
        function setCurrentZoneItem(id) {
            appState.currentZoneItem = id;
            appState.selectedShape = null;
            appState.selectedPoint = null;
            renderZoneItems();
            redrawCanvas();
        }
        
        // Toggle zone item active state
        function toggleZoneItem(id) {
            const itemIndex = appState.zoneItems.findIndex(item => item.id === id);
            if (itemIndex !== -1) {
                appState.zoneItems[itemIndex].active = !appState.zoneItems[itemIndex].active;
                
                if (appState.currentZoneItem === id && !appState.zoneItems[itemIndex].active) {
                    appState.currentZoneItem = null;
                }
                
                renderZoneItems();
                redrawCanvas();
            }
        }
        
        // Delete a zone item
        function deleteZoneItem(id) {
            const confirmDelete = confirm('Are you sure you want to delete this zone item? All shapes using this item will also be deleted.');
            
            if (confirmDelete) {
                appState.zoneItems = appState.zoneItems.filter(item => item.id !== id);
                
                const itemColor = appState.zoneItems.find(item => item.id === id)?.color;
                if (itemColor) {
                    appState.usedColors = appState.usedColors.filter(color => color !== itemColor);
                }
                
                appState.shapes = appState.shapes.filter(shape => shape.zoneItemId !== id);
                
                // Update scenarios
                appState.scenarios.forEach(scenario => {
                    delete scenario.zones[id];
                });
                
                if (appState.currentZoneItem === id) {
                    appState.currentZoneItem = null;
                }
                
                renderZoneItems();
                renderScenarios();
                redrawCanvas();
            }
        }
        
        // Set current scenario
        function setCurrentScenario(id) {
            // Deactivate current scenario
            if (appState.currentScenario) {
                const oldScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
                if (oldScenario) {
                    oldScenario.active = false;
                }
            }
            
            // Activate new scenario
            const newScenario = appState.scenarios.find(s => s.id === id);
            if (newScenario) {
                newScenario.active = true;
                appState.currentScenario = id;
                
                // Update UI
                renderScenarios();
                renderZoneItems(); // Re-render zones to show only those active in this scenario
                redrawCanvas();
            }
        }
        
        // Toggle scenario visibility
        function toggleScenarioVisibility(id) {
            const scenario = appState.scenarios.find(s => s.id === id);
            if (scenario) {
                // Toggle visibility of all zones in this scenario
                for (const zoneId in scenario.zones) {
                    scenario.zones[zoneId].visible = !scenario.zones[zoneId].visible;
                }
                redrawCanvas();
            }
        }
        
        // Open modal to add a new zone item
        function openAddZoneModal() {
            modalTitle.textContent = 'Add Zone Item';
            zoneNameInput.value = '';
            zoneColorInput.value = getUniqueColor();
            appState.editingItemId = null;
            
            // Populate scenario checkboxes
            populateScenarioCheckboxes([]);
            
            zoneModal.style.display = 'flex';
        }
        // Open modal to edit an existing zone item
        function openEditZoneModal(item) {
            modalTitle.textContent = 'Edit Zone Item';
            zoneNameInput.value = item.name;
            zoneColorInput.value = item.color;
            appState.editingItemId = item.id;
            
            // Populate scenario checkboxes with selected scenarios
            populateScenarioCheckboxes(item.activeInScenarios || []);
            
            zoneModal.style.display = 'flex';
        }
        
        // Populate scenario checkboxes in the zone modal
        function populateScenarioCheckboxes(selectedScenarios) {
            const checkboxContainer = document.getElementById('scenario-checkboxes');
            checkboxContainer.innerHTML = '';
            
            appState.scenarios.forEach(scenario => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'flex items-center';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `scenario-${scenario.id}`;
                checkbox.className = 'mr-2';
                checkbox.checked = selectedScenarios.includes(scenario.id);
                checkbox.value = scenario.id;
                
                const label = document.createElement('label');
                label.htmlFor = `scenario-${scenario.id}`;
                label.textContent = scenario.name;
                label.className = 'text-sm';
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                checkboxContainer.appendChild(checkboxDiv);
            });
        }
        
        // Close the zone modal
        function closeZoneModal() {
            zoneModal.style.display = 'none';
        }
        
        // Save a new or edited zone item
        function saveZoneItem() {
            const name = zoneNameInput.value.trim();
            let color = zoneColorInput.value;
            
            if (!name) {
                alert('Please enter a name for the zone item.');
                return;
            }
            
            // Get selected scenarios
            const selectedScenarios = [];
            const checkboxes = document.querySelectorAll('#scenario-checkboxes input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedScenarios.push(checkbox.value);
                }
            });
            
            if (selectedScenarios.length === 0) {
                alert('Please select at least one scenario for this zone.');
                return;
            }
            
            if (appState.editingItemId) {
                const itemIndex = appState.zoneItems.findIndex(item => item.id === appState.editingItemId);
                
                if (itemIndex !== -1) {
                    const oldColor = appState.zoneItems[itemIndex].color;
                    if (oldColor !== color) {
                        const colorInUse = appState.zoneItems.some(item =>
                            item.id !== appState.editingItemId && item.color === color
                        );
                        
                        if (colorInUse) {
                            color = getUniqueColor();
                        }
                        
                        appState.usedColors = appState.usedColors.filter(c => c !== oldColor);
                        appState.usedColors.push(color);
                    }
                    
                    appState.zoneItems[itemIndex].name = name;
                    appState.zoneItems[itemIndex].color = color;
                    appState.zoneItems[itemIndex].activeInScenarios = selectedScenarios;
                    
                    // Update shapes with this zone item
                    appState.shapes.forEach(shape => {
                        if (shape.zoneItemId === appState.editingItemId) {
                            shape.color = color;
                        }
                    });
                    
                    // Update scenario zones
                    appState.scenarios.forEach(scenario => {
                        scenario.zones[appState.editingItemId] = {
                            visible: selectedScenarios.includes(scenario.id)
                        };
                    });
                }
            } else {
                const colorInUse = appState.zoneItems.some(item => item.color === color);
                if (colorInUse) {
                    color = getUniqueColor();
                }
                
                const newItem = {
                    id: generateId(),
                    name: name,
                    color: color,
                    active: true,
                    activeInScenarios: selectedScenarios
                };
                
                appState.zoneItems.push(newItem);
                appState.usedColors.push(color);
                
                // Add to scenarios
                appState.scenarios.forEach(scenario => {
                    scenario.zones[newItem.id] = {
                        visible: selectedScenarios.includes(scenario.id)
                    };
                });
            }
            
            renderZoneItems();
            renderScenarios();
            closeZoneModal();
            redrawCanvas();
        }
        
        // (Removed toggleEditMode and edit/draw mode logic)
        
        // Check if a point is inside a shape
        function isPointInShape(x, y, shape) {
            let inside = false;
            const points = shape.points;
            
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x, yi = points[i].y;
                const xj = points[j].x, yj = points[j].y;
                
                const intersect = ((yi > y) !== (yj > y)) && 
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        // Find the closest point on a line segment from a given point
        function closestPointOnLine(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = x - xx;
            const dy = y - yy;
            
            return {
                x: xx,
                y: yy,
                distance: Math.sqrt(dx * dx + dy * dy),
                param: param
            };
        }
        
        // Find the closest point and line segment to the cursor
        function findClosestPointAndLine(x, y) {
            const threshold = 10; // distance threshold for selection
            let closestPoint = null;
            let closestDistance = Infinity;
            let closestShape = null;
            let closestPointIndex = -1;
            
            let closestLinePoint = null;
            let closestLineDistance = Infinity;
            let closestLineShape = null;
            let closestLineIndex = -1;
            
            appState.shapes.forEach((shape, shapeIndex) => {
                // Skip shapes that are from inactive zone items
                const zoneItem = appState.zoneItems.find(item => item.id === shape.zoneItemId);
                if (!zoneItem || !zoneItem.active) return;
                
                // Check if any points are close to the cursor
                shape.points.forEach((point, pointIndex) => {
                    const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                    if (distance < threshold && distance < closestDistance) {
                        closestDistance = distance;
                        closestPoint = point;
                        closestShape = shape;
                        closestPointIndex = pointIndex;
                    }
                });
                
                // Check if cursor is close to any line segments
                for (let i = 0; i < shape.points.length; i++) {
                    const p1 = shape.points[i];
                    const p2 = shape.points[(i + 1) % shape.points.length];
                    
                    const closest = closestPointOnLine(x, y, p1.x, p1.y, p2.x, p2.y);
                    
                    if (closest.distance < threshold && closest.distance < closestLineDistance) {
                        closestLineDistance = closest.distance;
                        closestLinePoint = closest;
                        closestLineShape = shape;
                        closestLineIndex = i;
                    }
                }
            });
            
            // If we found a point, return that
            if (closestPoint) {
                return {
                    type: 'point',
                    point: closestPoint,
                    shape: closestShape,
                    index: closestPointIndex,
                    distance: closestDistance
                };
            }
            
            // Otherwise, if we found a line, return that
            if (closestLinePoint) {
                return {
                    type: 'line',
                    point: closestLinePoint,
                    shape: closestLineShape,
                    index: closestLineIndex,
                    distance: closestLineDistance
                };
            }
            
            return null;
        }
        
        // Helper function to adjust mouse coordinates based on zoom, pan, and image offset
        function adjustCoordinates(rawX, rawY) {
            // First, adjust for pan offset and zoom level
            // We need to reverse the transformations applied in redrawCanvas
            const adjustedX = (rawX - appState.panOffset.x) / appState.zoomLevel;
            const adjustedY = (rawY - appState.panOffset.y) / appState.zoomLevel;
            
            // Return adjusted coordinates
            return {
                x: adjustedX,
                y: adjustedY
            };
        }
        
        // Draw a delete button for the selected shape
        function drawDeleteButton(shape) {
            // Calculate the center of the shape
            let centerX = 0;
            let centerY = 0;
            
            shape.points.forEach(point => {
                centerX += point.x;
                centerY += point.y;
            });
            
            centerX /= shape.points.length;
            centerY /= shape.points.length;
            
            // Draw a red circle with an X
            const buttonRadius = 15;
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, buttonRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ff0000';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw X
            ctx.beginPath();
            ctx.moveTo(centerX - 8, centerY - 8);
            ctx.lineTo(centerX + 8, centerY + 8);
            ctx.moveTo(centerX + 8, centerY - 8);
            ctx.lineTo(centerX - 8, centerY + 8);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Store the button position for hit testing
            appState.deleteButtonPosition = { x: centerX, y: centerY, radius: buttonRadius };
        }
        
        // Check if a point is inside the delete button
        function isPointInDeleteButton(x, y) {
            if (!appState.deleteButtonPosition) return false;
            
            const dx = x - appState.deleteButtonPosition.x;
            const dy = y - appState.deleteButtonPosition.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return distance <= appState.deleteButtonPosition.radius;
        }
        
        // Delete the selected shape
        function deleteSelectedShape() {
            if (!appState.selectedShape) return;
            
            const shapeIndex = appState.shapes.indexOf(appState.selectedShape);
            if (shapeIndex !== -1) {
                const action = {
                    type: 'delete_shape',
                    shape: appState.selectedShape,
                    shapeIndex: shapeIndex
                };
                appState.undoStack.push(action);
                
                appState.shapes.splice(shapeIndex, 1);
                appState.selectedShape = null;
                appState.deleteButtonPosition = null;
                redrawCanvas();
            }
        }
        
        // Handle mouse down event
        function handleMouseDown(e) {
            if (e.button === 2) return; // Handle right-click separately

            const rect = canvas.getBoundingClientRect();
            // Get raw coordinates relative to canvas
            let rawX = e.clientX - rect.left;
            let rawY = e.clientY - rect.top;
            
            // Check if we're panning (middle mouse button or Shift+left click)
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                appState.isPanning = true;
                appState.lastMousePos = { x: rawX, y: rawY };
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            // Adjust coordinates using helper function
            const { x, y } = adjustCoordinates(rawX, rawY);

            // Allow shape/point manipulation in both modes
            const closest = findClosestPointAndLine(x, y);

            // Check if we clicked on the delete button
            if (appState.selectedShape && isPointInDeleteButton(x, y)) {
                deleteSelectedShape();
                return;
            }
            
            // Check if we're clicking on or manipulating an existing shape
            if (closest && closest.type === 'point') {
                // Clicked on a point: select for dragging
                appState.selectedShape = closest.shape;
                appState.selectedPoint = closest.index;
                appState.isDragging = true;
                appState.dragStartPos = { x, y };
                redrawCanvas();
                return;
            }

            if (closest && closest.type === 'line') {
                // Clicked on an edge: add a new point to the edge
                const newPoint = {
                    x: closest.point.x,
                    y: closest.point.y
                };
                closest.shape.points.splice(closest.index + 1, 0, newPoint);

                const action = {
                    type: 'add_shape_point',
                    shape: closest.shape,
                    pointIndex: closest.index + 1,
                    point: newPoint
                };
                appState.undoStack.push(action);

                redrawCanvas();
                return;
            }

            // Check if we clicked inside a shape (for dragging the whole shape)
            for (let i = appState.shapes.length - 1; i >= 0; i--) {
                const shape = appState.shapes[i];
                const zoneItem = appState.zoneItems.find(item => item.id === shape.zoneItemId);

                if (!zoneItem || !zoneItem.active) continue;

                if (isPointInShape(x, y, shape)) {
                    appState.selectedShape = shape;
                    appState.selectedPoint = null;
                    appState.isDragging = true;
                    appState.dragStartPos = { x, y };
                    redrawCanvas();
                    return;
                }
            }

            // If we didn't click on any existing shape, either start a new shape or add to current shape
            if (appState.currentShape.length === 0) {
                // Start a new shape if we have a zone selected
                if (appState.currentZoneItem) {
                    appState.selectedShape = null;
                    appState.selectedPoint = null;
                    appState.currentShape.push({ x, y });
                    
                    const action = {
                        type: 'add_point',
                        point: { x, y },
                        shapeIndex: 0
                    };
                    appState.undoStack.push(action);
                    
                    redrawCanvas();
                    return;
                } else {
                    alert('Please select a zone item before drawing.');
                    return;
                }
            }
            // If we already have a shape in progress, add to it
            if (appState.currentShape.length > 0) {
                appState.currentShape.push({ x, y });

                const action = {
                    type: 'add_point',
                    point: { x, y },
                    shapeIndex: appState.currentShape.length - 1
                };
                appState.undoStack.push(action);

                redrawCanvas();
            }
        }

        // Handle mouse move event
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            // Get raw coordinates relative to canvas
            let rawX = e.clientX - rect.left;
            let rawY = e.clientY - rect.top;
            
            // Check if we're panning
            if (appState.isPanning) {
                // Calculate how much the mouse has moved
                const deltaX = rawX - appState.lastMousePos.x;
                const deltaY = rawY - appState.lastMousePos.y;
                
                // Update the pan offset
                appState.panOffset.x += deltaX;
                appState.panOffset.y += deltaY;
                
                // Update the last mouse position
                appState.lastMousePos = { x: rawX, y: rawY };
                
                // Set cursor style
                canvas.style.cursor = 'grabbing';
                
                // Redraw the canvas with the new pan offset
                redrawCanvas();
                return;
            }
            
            // Adjust coordinates using helper function
            const { x, y } = adjustCoordinates(rawX, rawY);

            // Allow dragging when we have a selected shape and are dragging
            if (appState.selectedShape && appState.isDragging) {
                const deltaX = x - appState.dragStartPos.x;
                const deltaY = y - appState.dragStartPos.y;

                if (appState.selectedShape) {
                    if (appState.selectedPoint !== null) {
                        // Dragging a single point
                        appState.selectedShape.points[appState.selectedPoint].x += deltaX;
                        appState.selectedShape.points[appState.selectedPoint].y += deltaY;
                    } else {
                        // Dragging the entire shape
                        appState.selectedShape.points.forEach(point => {
                            point.x += deltaX;
                            point.y += deltaY;
                        });
                    }

                    appState.dragStartPos = { x, y };
                    redrawCanvas();
                }
            }
        }

        // Handle double-click event for adding a point to an edge in draw mode
        function handleCanvasDblClick(e) {
            if (!appState.selectedShape) return; // Only if a shape is selected

            const rect = canvas.getBoundingClientRect();
            // Get raw coordinates relative to canvas
            let rawX = e.clientX - rect.left;
            let rawY = e.clientY - rect.top;
            
            // Adjust coordinates using helper function
            const { x, y } = adjustCoordinates(rawX, rawY);

            // Only allow adding to the selected shape
            const threshold = 10;
            // Find the closest line on the selected shape
            let closestLine = null;
            let closestDistance = Infinity;
            let closestIndex = -1;
            const points = appState.selectedShape.points;
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                const closest = closestPointOnLine(x, y, p1.x, p1.y, p2.x, p2.y);
                if (closest.distance < threshold && closest.distance < closestDistance) {
                    closestDistance = closest.distance;
                    closestLine = closest;
                    closestIndex = i;
                }
            }
            if (closestLine) {
                // Insert new point at the double-clicked position
                const newPoint = { x: closestLine.x, y: closestLine.y };
                appState.selectedShape.points.splice(closestIndex + 1, 0, newPoint);

                const action = {
                    type: 'add_shape_point',
                    shape: appState.selectedShape,
                    pointIndex: closestIndex + 1,
                    point: newPoint
                };
                appState.undoStack.push(action);

                redrawCanvas();
            }
        }
        
        // Handle mouse up event
        function handleMouseUp(e) {
            // Reset panning state
            if (appState.isPanning) {
                appState.isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
            
            if (appState.isDragging) {
                appState.isDragging = false;
                
                // Save the move action for undo
                if (appState.selectedShape) {
                    const action = {
                        type: 'move_shape',
                        shape: JSON.parse(JSON.stringify(appState.selectedShape)),
                        shapeIndex: appState.shapes.indexOf(appState.selectedShape)
                    };
                    appState.undoStack.push(action);
                }
            }
        }
        
        // Handle right-click event
        function handleContextMenu(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            // Get raw coordinates relative to canvas
            let rawX = e.clientX - rect.left;
            let rawY = e.clientY - rect.top;
            
            // Adjust coordinates using helper function
            const { x, y } = adjustCoordinates(rawX, rawY);
            
            // Check if we're interacting with an existing shape
            const closest = findClosestPointAndLine(x, y);
            
            if (closest) {
                if (closest.type === 'point') {
                    // Remove the point if it's not the only point
                    if (closest.shape.points.length > 3) {
                        closest.shape.points.splice(closest.index, 1);
                        
                        const action = {
                            type: 'remove_point',
                            shape: closest.shape,
                            pointIndex: closest.index,
                            point: closest.point
                        };
                        appState.undoStack.push(action);
                        
                        redrawCanvas();
                        return;
                    }
                } else if (closest.type === 'line') {
                    // Add a new point on the line
                    const newPoint = {
                        x: closest.point.x,
                        y: closest.point.y
                    };
                    
                    closest.shape.points.splice(closest.index + 1, 0, newPoint);
                    
                    const action = {
                        type: 'add_shape_point',
                        shape: closest.shape,
                        pointIndex: closest.index + 1,
                        point: newPoint
                    };
                    appState.undoStack.push(action);
                    
                    redrawCanvas();
                    return;
                }
            }
            
            
            // If not interacting with an existing shape, handle current shape being drawn
            // In draw mode, right-click to remove the last point
            if (appState.currentShape.length > 0) {
                appState.currentShape.pop();
                
                const action = {
                    type: 'remove_current_point'
                };
                appState.undoStack.push(action);
                
                redrawCanvas();
            }
        }
        
        // Handle mouse wheel for zooming
        function handleWheel(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Convert mouse position to canvas coordinates before zoom
            const canvasX = (mouseX - appState.panOffset.x) / appState.zoomLevel;
            const canvasY = (mouseY - appState.panOffset.y) / appState.zoomLevel;
            
            // Adjust zoom level based on wheel direction
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            appState.zoomLevel *= zoomFactor;
            
            // Limit zoom level to reasonable bounds
            appState.zoomLevel = Math.max(0.1, Math.min(10, appState.zoomLevel));
            
            // Adjust pan offset to zoom toward/away from mouse position
            appState.panOffset.x = mouseX - canvasX * appState.zoomLevel;
            appState.panOffset.y = mouseY - canvasY * appState.zoomLevel;
            
            redrawCanvas();
        }
        
        // Handle keyboard events
        function handleKeyDown(e) {
            // Enter key to complete the shape
            if (e.key === 'Enter' && appState.currentShape.length >= 3) {
                completeCurrentShape();
            }
            
            // Undo (Ctrl+Z or Cmd+Z)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undoLastAction();
            }
            
            // Delete key to delete selected shape
            if (e.key === 'Delete' && appState.selectedShape) {
                const shapeIndex = appState.shapes.indexOf(appState.selectedShape);
                if (shapeIndex !== -1) {
                    const action = {
                        type: 'delete_shape',
                        shape: appState.selectedShape,
                        shapeIndex: shapeIndex
                    };
                    appState.undoStack.push(action);
                    
                    appState.shapes.splice(shapeIndex, 1);
                    appState.selectedShape = null;
                    redrawCanvas();
                }
            }
        }
        
        // Complete the current shape being drawn
        function completeCurrentShape() {
            if (appState.currentShape.length >= 3 && appState.currentZoneItem) {
                const zoneItem = appState.zoneItems.find(item => item.id === appState.currentZoneItem);
                
                if (zoneItem) {
                    const shape = {
                        zoneItemId: zoneItem.id,
                        color: zoneItem.color,
                        points: [...appState.currentShape]
                    };
                    
                    appState.shapes.push(shape);
                    
                    const action = {
                        type: 'complete_shape',
                        shape: shape,
                        shapeIndex: appState.shapes.length - 1
                    };
                    appState.undoStack.push(action);
                    
                    appState.currentShape = [];
                    redrawCanvas();
                }
            }
        }
        
        // Undo the last action
        function undoLastAction() {
            if (appState.undoStack.length > 0) {
                const lastAction = appState.undoStack.pop();
                
                switch (lastAction.type) {
                    case 'add_point':
                        if (appState.currentShape.length > 0) {
                            appState.currentShape.pop();
                        }
                        break;
                        
                    case 'remove_current_point':
                        if (lastAction.point) {
                            appState.currentShape.push(lastAction.point);
                        }
                        break;
                        
                    case 'complete_shape':
                        if (lastAction.shapeIndex !== undefined) {
                            appState.shapes.splice(lastAction.shapeIndex, 1);
                        }
                        break;
                        
                    case 'move_shape':
                        if (lastAction.shape && lastAction.shapeIndex !== undefined) {
                            appState.shapes[lastAction.shapeIndex] = JSON.parse(JSON.stringify(lastAction.shape));
                        }
                        break;
                        
                    case 'delete_shape':
                        if (lastAction.shape) {
                            appState.shapes.splice(lastAction.shapeIndex, 0, lastAction.shape);
                        }
                        break;
                        
                    case 'add_shape_point':
                        if (lastAction.shape && lastAction.pointIndex !== undefined) {
                            lastAction.shape.points.splice(lastAction.pointIndex, 1);
                        }
                        break;
                        
                    case 'remove_point':
                        if (lastAction.shape && lastAction.pointIndex !== undefined && lastAction.point) {
                            lastAction.shape.points.splice(lastAction.pointIndex, 0, lastAction.point);
                        }
                        break;
                }
                
                redrawCanvas();
            }
        }
        
        // Handle file selection for background upload
        function handleBackgroundUpload(e) {
            const file = e.target.files[0];
            if (file && file.type.match('image.*')) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        appState.backgroundImage = img;
                        // Responsive: set canvas size to container, then redraw
                        if (typeof resizeCanvasToContainer === 'function') {
                            resizeCanvasToContainer();
                        }
                        redrawCanvas();
                        // Enable download button after image is loaded
                        downloadPngBtn.disabled = false;
                        downloadPngBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    };
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // Download the canvas as PNG
        function downloadCanvasAsPNG() {
            const link = document.createElement('a');
            link.download = 'garbiczland-plan.png';
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Redraw the entire canvas
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Save the current context state
            ctx.save();
            
            // Apply zoom and pan transformations
            ctx.translate(appState.panOffset.x, appState.panOffset.y);
            ctx.scale(appState.zoomLevel, appState.zoomLevel);
            
            // Draw background image if available
            if (appState.backgroundImage) {
                // Draw the image at its natural size (1:1)
                ctx.drawImage(appState.backgroundImage, 0, 0);
            }
            
            // Get visible shapes based on scenarios
            const visibleZoneIds = {};
            
            // First, mark all zones as not visible
            appState.zoneItems.forEach(item => {
                visibleZoneIds[item.id] = false;
            });
            
            // Then, make zones visible if they are active and in the current scenario
            const currentScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
            if (currentScenario) {
                appState.zoneItems.forEach(item => {
                    // Check if zone is active and in the current scenario
                    if (item.active && item.activeInScenarios.includes(currentScenario.id)) {
                        visibleZoneIds[item.id] = true;
                    }
                });
                
                // Apply scenario visibility settings
                for (const zoneId in currentScenario.zones) {
                    if (!currentScenario.zones[zoneId].visible) {
                        visibleZoneIds[zoneId] = false;
                    }
                }
            }
            
            // Draw all completed shapes
            appState.shapes.forEach(shape => {
                if (visibleZoneIds[shape.zoneItemId]) {
                    const isSelected = shape === appState.selectedShape;
                    drawShape(shape.points, shape.color, 0.5, isSelected);
                }
            });
            
            // Draw current shape being created
            if (appState.currentShape.length > 0) {
                const zoneItem = appState.zoneItems.find(item => item.id === appState.currentZoneItem);
                if (zoneItem) {
                    drawShape(appState.currentShape, zoneItem.color, 0.5, false);
                    
                    // Draw points for current shape
                    appState.currentShape.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = zoneItem.color;
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });
                }
            }
            
            // Draw handles for the selected shape
            if (appState.selectedShape) {
                // Draw control points
                appState.selectedShape.points.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = index === appState.selectedPoint ? '#ff0000' : '#ffffff';
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // Draw delete button
                drawDeleteButton(appState.selectedShape);
            }
            
            // Restore the context state
            ctx.restore();
        }
        
        // Draw a shape on the canvas
        function drawShape(points, color, opacity, isSelected) {
            if (points.length < 3) return;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.closePath();
            
            // Fill with semi-transparent color
            const alpha = Math.floor(opacity * 255).toString(16).padStart(2, '0');
            ctx.fillStyle = color + alpha;
            ctx.fill();
            
            // Draw outline
            ctx.strokeStyle = isSelected ? '#ff0000' : color;
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.stroke();
        }
        
        // --- Scenario Modal Logic ---

        // Track which scenario is being edited (null for add)
        appState.editingScenarioId = null;

        function openAddScenarioModal() {
            scenarioModalTitle.textContent = 'Add Scenario';
            scenarioNameInput.value = '';
            scenarioDescriptionInput.value = '';
            scenarioActiveInput.checked = false;
            appState.editingScenarioId = null;
            scenarioModal.style.display = 'flex';
        }

        function openEditScenarioModal(scenario) {
            scenarioModalTitle.textContent = 'Edit Scenario';
            scenarioNameInput.value = scenario.name;
            scenarioDescriptionInput.value = scenario.description || '';
            scenarioActiveInput.checked = !!scenario.active;
            appState.editingScenarioId = scenario.id;
            scenarioModal.style.display = 'flex';
        }

        function closeScenarioModal() {
            scenarioModal.style.display = 'none';
        }

        function saveScenario() {
            const name = scenarioNameInput.value.trim();
            const description = scenarioDescriptionInput.value.trim();
            const isActive = scenarioActiveInput.checked;

            if (!name) {
                alert('Please enter a name for the scenario.');
                return;
            }

            // If editing, update existing scenario
            if (appState.editingScenarioId) {
                const idx = appState.scenarios.findIndex(s => s.id === appState.editingScenarioId);
                if (idx !== -1) {
                    appState.scenarios[idx].name = name;
                    appState.scenarios[idx].description = description;
                    // If set as active, deactivate others
                    if (isActive) {
                        appState.scenarios.forEach(s => s.active = false);
                        appState.scenarios[idx].active = true;
                        appState.currentScenario = appState.scenarios[idx].id;
                    }
                }
            } else {
                // Generate unique id
                let newId = name.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                if (appState.scenarios.some(s => s.id === newId)) {
                    newId = generateId();
                }
                // Add new scenario
                const newScenario = {
                    id: newId,
                    name,
                    description,
                    active: isActive,
                    zones: {}
                };
                // Initialize zones visibility
                appState.zoneItems.forEach(zone => {
                    newScenario.zones[zone.id] = {
                        visible: zone.activeInScenarios.includes(newScenario.id)
                    };
                });
                if (isActive) {
                    appState.scenarios.forEach(s => s.active = false);
                    appState.currentScenario = newScenario.id;
                }
                appState.scenarios.push(newScenario);
            }

            // If set as active, ensure only one is active
            if (isActive) {
                appState.scenarios.forEach(s => {
                    if (s.id !== (appState.editingScenarioId || (appState.scenarios[appState.scenarios.length - 1]?.id))) {
                        s.active = false;
                    }
                });
            }

            renderScenarios();
            renderZoneItems();
            closeScenarioModal();
            redrawCanvas();
        }

        function loadVersionsFromLocalStorage() {
            const savedVersions = localStorage.getItem('garbiczlandVersions');
            if (savedVersions) {
                try {
                    appState.versions = JSON.parse(savedVersions);
                } catch (err) {
                    console.error('Error parsing saved versions:', err);
                }
            }
        }

        function deleteScenario(id) {
            // Prevent deleting the last scenario
            if (appState.scenarios.length <= 1) {
                alert('At least one scenario must exist.');
                return;
            }
            // Prevent deleting if any zone would have no scenario
            const zonesWithOnlyThisScenario = appState.zoneItems.filter(zone =>
                zone.activeInScenarios.length === 1 && zone.activeInScenarios[0] === id
            );
            if (zonesWithOnlyThisScenario.length > 0) {
                alert('Cannot delete this scenario because some zones are only active in this scenario.');
                return;
            }
            if (!confirm('Are you sure you want to delete this scenario?')) return;
            // Remove scenario from appState
            appState.scenarios = appState.scenarios.filter(s => s.id !== id);
            // Remove from all zoneItems' activeInScenarios
            appState.zoneItems.forEach(zone => {
                zone.activeInScenarios = zone.activeInScenarios.filter(sid => sid !== id);
            });
            // Remove from all scenario.zones
            appState.scenarios.forEach(scenario => {
                for (const zoneId in scenario.zones) {
                    if (scenario.zones[zoneId] && scenario.zones[zoneId].visible && !appState.zoneItems.find(z => z.id === zoneId)) {
                        delete scenario.zones[zoneId];
                    }
                }
            });
            // If deleted scenario was active, set another as active
            if (appState.currentScenario === id) {
                if (appState.scenarios.length > 0) {
                    appState.currentScenario = appState.scenarios[0].id;
                    appState.scenarios[0].active = true;
                } else {
                    appState.currentScenario = null;
                }
            }
            renderScenarios();
            renderZoneItems();
            redrawCanvas();
        }

        // Function to open the save new version modal
        function openSaveNewVersionModal() {
            newVersionNameInput.value = 'Version ' + (appState.versions.length + 1);
            saveNewVersionModal.style.display = 'flex';
        }
        
        // Function to close the save new version modal
        function closeSaveNewVersionModal() {
            saveNewVersionModal.style.display = 'none';
        }
        
        // Function to save a new version
        function saveNewVersion() {
            const versionName = newVersionNameInput.value.trim();
            
            if (!versionName) {
                alert('Please enter a name for the version.');
                return;
            }
            
            // Check for duplicate names and make unique
            const uniqueName = getUniqueVersionName(versionName);
            
            // Include background image URL in the version data
            const backgroundImageUrl = appState.backgroundImage ? appState.backgroundImage.src : null;
            
            const newVersion = {
                timestamp: Date.now(),
                versionName: uniqueName,
                data: {
                    zoneItems: JSON.parse(JSON.stringify(appState.zoneItems)),
                    scenarios: JSON.parse(JSON.stringify(appState.scenarios)),
                    shapes: JSON.parse(JSON.stringify(appState.shapes)),
                    usedColors: JSON.parse(JSON.stringify(appState.usedColors)),
                    currentScenario: appState.currentScenario,
                    backgroundImageUrl: backgroundImageUrl
                }
            };
            
            appState.versions.push(newVersion);
            renderVersions(); // Update the UI
            localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
            
            closeSaveNewVersionModal();
        }

        // Function to load a version
        function loadVersion(version) {
            if (confirm('Are you sure you want to load this version? Current data will be replaced.')) {
                appState.zoneItems = JSON.parse(JSON.stringify(version.data.zoneItems));
                appState.scenarios = JSON.parse(JSON.stringify(version.data.scenarios));
                appState.shapes = JSON.parse(JSON.stringify(version.data.shapes));
                appState.usedColors = JSON.parse(JSON.stringify(version.data.usedColors));
                appState.currentScenario = version.data.currentScenario;
                
                // Set this as the current version
                appState.currentVersion = version.timestamp;
                
                // Load background image if available in the version data
                if (version.data.backgroundImageUrl) {
                    const img = new Image();
                    img.onload = function() {
                        appState.backgroundImage = img;
                        redrawCanvas();
                        // Enable download button after image is loaded
                        downloadPngBtn.disabled = false;
                        downloadPngBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    };
                    img.src = version.data.backgroundImageUrl;
                }
                
                
                renderZoneItems();
                renderScenarios();
                renderVersions();
                redrawCanvas();
            }
        }
        
        // Function to save changes to the current version
        function saveCurrentVersion() {
            if (appState.currentVersion === null) {
                alert('No version is currently loaded.');
                return;
            }
            
            const version = appState.versions.find(v => v.timestamp === appState.currentVersion);
            if (!version) {
                alert('Current version not found.');
                return;
            }
            
            // Update the version data with the current state
            version.data = {
                zoneItems: JSON.parse(JSON.stringify(appState.zoneItems)),
                scenarios: JSON.parse(JSON.stringify(appState.scenarios)),
                shapes: JSON.parse(JSON.stringify(appState.shapes)),
                usedColors: JSON.parse(JSON.stringify(appState.usedColors)),
                currentScenario: appState.currentScenario,
                backgroundImageUrl: appState.backgroundImage ? appState.backgroundImage.src : null,
                versionName: version.versionName
            };
            
            // Save to localStorage
            localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
            
            alert(`Version "${version.versionName}" has been updated with your changes.`);
        }

        // Function to delete a version
        function deleteVersion(version) {
            if (confirm(`Are you sure you want to delete the version: ${version.versionName}?`)) {
                appState.versions = appState.versions.filter(v => v.timestamp !== version.timestamp);
                renderVersions(); // Update the UI
                localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
            }
        }

        // Version being edited
        appState.editingVersionId = null;
        
        // Function to open the rename version modal
        function renameVersion(version) {
            versionModalTitle.textContent = 'Rename Version';
            versionNameInput.value = version.versionName;
            appState.editingVersionId = version.timestamp;
            versionModal.style.display = 'flex';
        }
        
        // Function to close the version modal
        function closeVersionModal() {
            versionModal.style.display = 'none';
        }
        
        // Function to save the renamed version
        function saveVersionName() {
            const name = versionNameInput.value.trim();
            
            if (!name) {
                alert('Please enter a name for the version.');
                return;
            }
            
            if (appState.editingVersionId) {
                const version = appState.versions.find(v => v.timestamp === appState.editingVersionId);
                if (version) {
                    version.versionName = name;
                    renderVersions(); // Update the UI
                    localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
                }
            }
            
            closeVersionModal();
        }

        // Function to check for duplicate version names and add " copy" if needed
        function getUniqueVersionName(name) {
            // Check if the name already exists
            let newName = name;
            let counter = 1;
            
            // First check if the name exists
            while (appState.versions.some(v => v.versionName === newName)) {
                if (counter === 1) {
                    newName = `${name} copy`;
                } else {
                    newName = `${name} copy (${counter})`;
                }
                counter++;
            }
            
            return newName;
        }
        
        // Function to share a version (copy deeplink to clipboard)
        function shareVersion(version) {
            // Create a copy of the version data to avoid modifying the original
            const versionDataCopy = JSON.parse(JSON.stringify(version.data));
            
            // Make sure the background image URL is included in the version data
            if (appState.backgroundImage && !versionDataCopy.backgroundImageUrl) {
                versionDataCopy.backgroundImageUrl = appState.backgroundImage.src;
            }
            
            // Include the version name in the data
            versionDataCopy.versionName = version.versionName;
            
            // Create a deeplink with the version data in the URL hash
            const versionData = JSON.stringify(versionDataCopy);
            const encodedData = encodeURIComponent(versionData);
            const deeplink = `${window.location.origin}${window.location.pathname}#version=${encodedData}`;
            
            // Copy to clipboard
            try {
                navigator.clipboard.writeText(deeplink).then(() => {
                    alert('Deeplink copied to clipboard! Share this link to share your version.');
                }).catch(err => {
                    console.error('Failed to copy deeplink: ', err);
                    fallbackCopyToClipboard(deeplink);
                });
            } catch (err) {
                console.error('Clipboard API not available: ', err);
                fallbackCopyToClipboard(deeplink);
            }
        }
        
        // Fallback method for copying to clipboard
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';  // Avoid scrolling to bottom
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    alert('Deeplink copied to clipboard! Share this link to share your version.');
                } else {
                    alert('Failed to copy deeplink. Please copy this URL manually: ' + text);
                }
            } catch (err) {
                console.error('Fallback clipboard copy failed: ', err);
                alert('Failed to copy deeplink. Please copy this URL manually: ' + text);
            }
            
            document.body.removeChild(textArea);
        }
        
        // Function to check for a version in the URL hash and import it
        function checkForVersionInHash() {
            if (window.location.hash) {
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                const versionData = hashParams.get('version');
                
                if (versionData) {
                    try {
                        const decodedData = decodeURIComponent(versionData);
                        const parsedData = JSON.parse(decodedData);
                        
                        if (!parsedData.zoneItems || !parsedData.scenarios || !parsedData.shapes ||
                            !parsedData.usedColors || parsedData.currentScenario === undefined) {
                            throw new Error('Invalid version data format.');
                        }
                        
                        // Load the version data directly into the application state
                        appState.zoneItems = JSON.parse(JSON.stringify(parsedData.zoneItems));
                        appState.scenarios = JSON.parse(JSON.stringify(parsedData.scenarios));
                        appState.shapes = JSON.parse(JSON.stringify(parsedData.shapes));
                        appState.usedColors = JSON.parse(JSON.stringify(parsedData.usedColors));
                        appState.currentScenario = parsedData.currentScenario;
                        
                        // Load background image if available in the imported data
                        if (parsedData.backgroundImageUrl) {
                            const img = new Image();
                            img.onload = function() {
                                appState.backgroundImage = img;
                                redrawCanvas();
                                // Enable download button after image is loaded
                                downloadPngBtn.disabled = false;
                                downloadPngBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                            };
                            img.src = parsedData.backgroundImageUrl;
                        }
                        
                        // Update UI
                        renderZoneItems();
                        renderScenarios();
                        redrawCanvas();
                        
                        // Use the original version name if available, otherwise use a default name
                        const originalName = parsedData.versionName || 'Imported Version';
                        const versionName = getUniqueVersionName(originalName);
                        
                        const newVersion = {
                            timestamp: Date.now(),
                            versionName: versionName,
                            data: parsedData
                        };
                        
                        appState.versions.push(newVersion);
                        // Set as current version
                        appState.currentVersion = newVersion.timestamp;
                        renderVersions();
                        localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
                        
                        // Clear the hash to avoid reimporting on refresh
                        window.location.hash = '';
                        
                        alert(`Version "${versionName}" has been imported and loaded successfully!`);
                    } catch (err) {
                        console.error('Failed to import version from URL: ', err);
                        alert('Invalid version data in URL.');
                    }
                }
            }
        }

        // Function to open the import version modal
        function openImportVersionModal() {
            importVersionDataInput.value = '';
            importVersionModal.style.display = 'flex';
        }
        
        // Function to close the import version modal
        function closeImportVersionModal() {
            importVersionModal.style.display = 'none';
        }
        
        // Function to import a version from the clipboard
        function importVersion() {
            const data = importVersionDataInput.value.trim();
            
            if (!data) {
                alert('Please enter version data or a deeplink.');
                return;
            }
            
            try {
                let parsedData;
                
                // Check if it's a deeplink
                if (data.includes('#version=')) {
                    const hashPart = data.split('#version=')[1];
                    const decodedData = decodeURIComponent(hashPart);
                    parsedData = JSON.parse(decodedData);
                } else {
                    // Try to parse as direct JSON
                    parsedData = JSON.parse(data);
                }
                
                if (!parsedData.zoneItems || !parsedData.scenarios || !parsedData.shapes ||
                    !parsedData.usedColors || parsedData.currentScenario === undefined) {
                    throw new Error('Invalid version data format.');
                }
                
                // Use the original version name if available, otherwise use a default name
                const originalName = parsedData.versionName || 'Imported Version';
                const uniqueName = getUniqueVersionName(originalName);
                
                const newVersion = {
                    timestamp: Date.now(),
                    versionName: uniqueName,
                    data: parsedData
                };
                
                // Load background image if available in the imported data
                if (parsedData.backgroundImageUrl) {
                    const img = new Image();
                    img.onload = function() {
                        appState.backgroundImage = img;
                        redrawCanvas();
                        // Enable download button after image is loaded
                        downloadPngBtn.disabled = false;
                        downloadPngBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    };
                    img.src = parsedData.backgroundImageUrl;
                }
                
                appState.versions.push(newVersion);
                // Set as current version
                appState.currentVersion = newVersion.timestamp;
                renderVersions(); // Update the UI
                localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
                
                closeImportVersionModal();
                alert(`Version "${uniqueName}" imported successfully!`);
            } catch (err) {
                console.error('Failed to import version data: ', err);
                alert('Invalid version data or deeplink.');
            }
        }
        // --- End Scenario Modal Logic ---

        // Initialize application
        async function initApp() {
            // Set up canvas and initial state
            function resizeCanvasToContainer() {
                const container = canvas.parentElement;
                if (container) {
                    // Get computed style to account for padding/borders
                    const rect = container.getBoundingClientRect();
                    canvas.width = rect.width;
                    
                    // Set canvas height to full container height, but max 1080px
                    const containerHeight = rect.height;
                    canvas.height = Math.min(containerHeight, 1080);
                }
            }
            resizeCanvasToContainer();
            window.addEventListener('resize', () => {
                resizeCanvasToContainer();
                redrawCanvas();
            });

            // Disable download button until background image is loaded
            downloadPngBtn.disabled = true;
            downloadPngBtn.classList.add('opacity-50', 'cursor-not-allowed');
            
            // Load configuration
            const config = await loadConfiguration();
            
            // Initialize default data
            initializeDefaultZoneItems(config);
            initializeDefaultScenarios(config);
            
            // Render UI components
            renderZoneItems();
            renderScenarios();
            renderVersions();
            
            // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', handleContextMenu);
            
            // Set up event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleCanvasDblClick);
            document.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('wheel', handleWheel);
            
            uploadBgBtn.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = handleBackgroundUpload;
                input.click();
            });
            importVersionBtn.addEventListener('click', openImportVersionModal);
            
            downloadPngBtn.addEventListener('click', downloadCanvasAsPNG);
            undoBtn.addEventListener('click', undoLastAction);
            // Removed editShapesBtn event listener
            addZoneBtn.addEventListener('click', openAddZoneModal);
            
            saveZoneBtn.addEventListener('click', saveZoneItem);
            cancelZoneBtn.addEventListener('click', closeZoneModal);
            modalClose.addEventListener('click', closeZoneModal);

            // Scenario modal event listeners
            addScenarioBtn.addEventListener('click', openAddScenarioModal);
            saveScenarioBtn.addEventListener('click', saveScenario);
            cancelScenarioBtn.addEventListener('click', closeScenarioModal);
            modalCloseScenario.addEventListener('click', closeScenarioModal);
            
            // Version modal event listeners
            saveVersionNameBtn.addEventListener('click', saveVersionName);
            cancelVersionBtn.addEventListener('click', closeVersionModal);
            modalCloseVersion.addEventListener('click', closeVersionModal);
            
            // Save new version modal event listeners
            confirmSaveNewVersionBtn.addEventListener('click', saveNewVersion);
            cancelSaveNewVersionBtn.addEventListener('click', closeSaveNewVersionModal);
            modalCloseSaveVersion.addEventListener('click', closeSaveNewVersionModal);
            
            // Import version modal event listeners
            confirmImportVersionBtn.addEventListener('click', importVersion);
            cancelImportVersionBtn.addEventListener('click', closeImportVersionModal);
            modalCloseImportVersion.addEventListener('click', closeImportVersionModal);

            //header
            const headerSaveVersionBtn = document.getElementById("save-version-btn");
            headerSaveVersionBtn.addEventListener("click", openSaveNewVersionModal);

            // Set up touch events for mobile
            let touchStartX = 0;
            document.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
            });
            
            document.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].clientX;
                const swipeDistance = touchStartX - touchEndX;
                
                if (swipeDistance > 100) {
                    undoLastAction();
                }
            });
            
            // Load data from localStorage if available
            const savedData = localStorage.getItem('garbiczlandData');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    
                    if (parsedData.zoneItems && parsedData.zoneItems.length > 0) {
                        // Add activeInScenarios if missing
                        parsedData.zoneItems.forEach(item => {
                            if (!item.activeInScenarios) {
                                item.activeInScenarios = [];
                                // Default to all scenarios if not specified
                                appState.scenarios.forEach(scenario => {
                                    if (scenario.zones[item.id]?.visible) {
                                        item.activeInScenarios.push(scenario.id);
                                    }
                                });
                            }
                        });
                        
                        appState.zoneItems = parsedData.zoneItems;
                    }
                    
                    if (parsedData.scenarios && parsedData.scenarios.length > 0) {
                        // Add active property if missing
                        parsedData.scenarios.forEach(scenario => {
                            if (scenario.active === undefined) {
                                scenario.active = false;
                            }
                        });
                        
                        appState.scenarios = parsedData.scenarios;
                        
                        // Set current scenario
                        const activeScenario = appState.scenarios.find(s => s.active);
                        if (activeScenario) {
                            appState.currentScenario = activeScenario.id;
                        } else if (appState.scenarios.length > 0) {
                            appState.currentScenario = appState.scenarios[0].id;
                            appState.scenarios[0].active = true;
                        }
                    }
                    
                    if (parsedData.shapes) {
                        appState.shapes = parsedData.shapes;
                    }
                    
                    if (parsedData.usedColors) {
                        appState.usedColors = parsedData.usedColors;
                    }
                    
                    if(parsedData.versions){
                        appState.versions = parsedData.versions;
                        const savedVersions = localStorage.getItem('garbiczlandVersions');

                    const img = new Image();
                        img.onload = function() {
                            appState.backgroundImage = img;
                            // Don't modify canvas dimensions, just use the image as is
                            // and let redrawCanvas handle the proper scaling
                            redrawCanvas();
                            // Enable download button after image is loaded
                            downloadPngBtn.disabled = false;
                            downloadPngBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        };
                        img.src = parsedData.backgroundImageUrl;
                    }
                    
                    renderZoneItems();
                    renderScenarios();
                    renderVersions();
                } catch (error) {
                    if(appState.versions.length > 0){
                        loadVersionsFromLocalStorage();
                        
                        // Check for version in URL hash
                        checkForVersionInHash();
                    }
                    console.error('Error loading saved data:', error);
                }
            }
            
            // Draw initial canvas
            redrawCanvas();
            
            loadVersionsFromLocalStorage();

            // Set up auto-save
            setInterval(() => {
                const dataToSave = {
                    zoneItems: appState.zoneItems,
                    scenarios: appState.scenarios,
                    shapes: appState.shapes,
                    usedColors: appState.usedColors,
                    currentScenario: appState.currentScenario,
                    backgroundImageUrl: appState.backgroundImage ? appState.backgroundImage.src : null,
                    versions: appState.versions
                };
                
                localStorage.setItem('garbiczlandData', JSON.stringify(dataToSave));
                localStorage.setItem('garbiczlandVersions', JSON.stringify(appState.versions));
            
            }, 10000); 
        }
        
         document.addEventListener('DOMContentLoaded', () => {
             initApp().catch(error => {console.error('Error initializing app:', error);});

             // Sidebar toggle logic for mobile
             const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
             const leftSidebar = document.getElementById('left-sidebar');
             const rightSidebar = document.getElementById('right-sidebar');
             let sidebarOpen = false;

             function updateSidebarVisibility() {
                 if (window.innerWidth < 768) {
                     if (sidebarOpen) {
                         leftSidebar.classList.remove('-translate-x-full');
                         leftSidebar.classList.add('translate-x-0');
                         rightSidebar.classList.remove('translate-x-full');
                         rightSidebar.classList.add('translate-x-0');
                     } else {
                         leftSidebar.classList.add('-translate-x-full');
                         leftSidebar.classList.remove('translate-x-0');
                         rightSidebar.classList.add('translate-x-full');
                         rightSidebar.classList.remove('translate-x-0');
                     }
                 } else {
                     leftSidebar.classList.remove('-translate-x-full', 'translate-x-0');
                     rightSidebar.classList.remove('translate-x-full', 'translate-x-0');
                 }
             }

             sidebarToggleBtn?.addEventListener('click', () => {
                 sidebarOpen = !sidebarOpen;
                 updateSidebarVisibility();
             });

             window.addEventListener('resize', () => {
                 if (window.innerWidth >= 768) {
                     sidebarOpen = false;
                 }
                 updateSidebarVisibility();
             });

             // Initialize sidebar visibility
             updateSidebarVisibility();
        });
    </script>
</body></html>
</html>

