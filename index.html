<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garbiczland Planner</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-color: #ffffff;
        }
        
        .color-swatch {
            width: 25px;
            height: 25px;
            display: inline-block;
            border: 1px solid #333;
            vertical-align: middle;
            margin-right: 10px;
        }
        
        .zone-item {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
        }
        
        .zone-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .zone-item.selected {
            background-color: rgba(0,0,0,0.1);
            font-weight: bold;
        }
        
        .deactivated {
            opacity: 0.5;
            text-decoration: line-through;
        }
        
        #main-canvas {
            cursor: crosshair;
            border: 1px solid #ddd;
            background-color: #ffffff;
        }
        
        .tool-button {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .tool-button:hover {
            background-color: #e0e0e0;
        }
        
        .tool-button i {
            margin-right: 5px;
        }
        
        .sidebar {
            height: calc(100vh - 60px);
            overflow-y: auto;
            padding: 15px;
            background-color: #ffffff;
            border: 1px solid #eaeaea;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-close {
            cursor: pointer;
            font-size: 20px;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .zone-controls {
            display: flex;
            justify-content: flex-end;
            gap: 5px;
        }
        
        .zone-control {
            cursor: pointer;
            padding: 3px;
            color: #666;
        }
        
        .zone-control:hover {
            color: #000;
        }
        
        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .scenario-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .scenario-item:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eaeaea;
        }
    </style>
</head>
<body>
    <div class="flex flex-col h-screen">
        <!-- Header Controls -->
        <header class="bg-white shadow-sm p-3 flex items-center justify-between">
            <div class="text-xl font-bold text-gray-800">Garbiczland Planner</div>
            <div class="flex items-center">
                <div class="mr-4 flex items-center">
                    <span class="text-sm text-gray-600 mr-2">Mode:</span>
                    <button id="edit-shapes-btn" class="tool-button">
                        <i class="fas fa-draw-polygon"></i> Draw Mode
                    </button>
                </div>
                <button id="upload-bg-btn" class="tool-button mr-2">
                    <i class="fas fa-image"></i> Upload Background
                </button>
                <button id="download-png-btn" class="tool-button">
                    <i class="fas fa-download"></i> Download as PNG
                </button>
            </div>
        </header>
        
        <!-- Main Content Area -->
        <div class="flex flex-1 overflow-hidden">
            <!-- Left Sidebar - Zone Items -->
            <div class="sidebar bg-white shadow-sm w-1/4 border-r border-gray-200">
                <h2 class="section-title">Zones</h2>
                <button id="add-zone-btn" class="tool-button mb-4 w-full">
                    <i class="fas fa-plus"></i> Add New Zone Item
                </button>
                <div id="zone-container" class="space-y-2"></div>
                <div class="text-xs text-gray-500 mt-4">
                    <p>Click on a zone to select it for drawing</p>
                </div>
            </div>
            
            <!-- Main Canvas Area -->
            <div class="flex-1 flex justify-center items-center bg-gray-50 p-4 overflow-auto">
                <canvas id="main-canvas" width="1000" height="800"></canvas>
            </div>
            
            <!-- Right Sidebar - Scenario Controls -->
            <div class="sidebar bg-white shadow-sm w-1/4 border-l border-gray-200">
                <h2 class="section-title">Scenarios</h2>
                <button id="add-scenario-btn" class="tool-button mb-4 w-full">
                    <i class="fas fa-plus"></i> Add New Scenario
                </button>
                <div id="scenarios-container" class="space-y-2 mb-6"></div>
                <h3 class="section-title mt-6">Drawing Controls</h3>
                <button id="undo-btn" class="tool-button mb-2 w-full">
                    <i class="fas fa-undo"></i> Undo (Ctrl+Z)
                </button>
                <div class="text-xs text-gray-500 mt-4">
                    <p>• Click on the map to add points</p>
                    <p>• Press Enter to complete a shape</p>
                    <p>• Click and drag to move shapes</p>
                    <p>• Right-click on points to delete them</p>
                    <p>• Right-click on lines to add points</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add/Edit Zone Item Modal -->
    <div id="zone-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modal-title" class="text-lg font-semibold">Add Zone Item</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="input-group">
                <label for="zone-name">Name:</label>
                <input type="text" id="zone-name" placeholder="Enter zone item name">
            </div>
            <div class="input-group">
                <label for="zone-color">Color:</label>
                <input type="color" id="zone-color">
                <div class="help-text">The system will ensure this color is unique</div>
            </div>
            <div class="input-group">
                <label>Active in Scenarios:</label>
                <div id="scenario-checkboxes" class="mt-2 space-y-2"></div>
                <div class="help-text">Select which scenarios this zone should appear in</div>
            </div>
            <div class="flex justify-end mt-4">
                <button id="cancel-zone-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                <button id="save-zone-btn" class="tool-button bg-blue-500 text-white hover:bg-blue-600">Save</button>
            </div>
        </div>
    </div>
        <!-- Add/Edit Scenario Modal -->
        <div id="scenario-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="scenario-modal-title" class="text-lg font-semibold">Add Scenario</h3>
                    <span class="modal-close-scenario" style="cursor:pointer;">&times;</span>
                </div>
                <div class="input-group">
                    <label for="scenario-name">Name:</label>
                    <input type="text" id="scenario-name" placeholder="Enter scenario name">
                </div>
                <div class="input-group">
                    <label for="scenario-description">Description:</label>
                    <input type="text" id="scenario-description" placeholder="Enter scenario description">
                </div>
                <div class="input-group">
                    <label for="scenario-active">
                        <input type="checkbox" id="scenario-active" class="mr-2">
                        Set as active scenario
                    </label>
                </div>
                <div class="flex justify-end mt-4">
                    <button id="cancel-scenario-btn" class="tool-button bg-gray-200 mr-2">Cancel</button>
                    <button id="save-scenario-btn" class="tool-button bg-blue-500 text-white hover:bg-blue-600">Save</button>
                </div>
            </div>
        </div>

    <script>
        // Main application state
        const appState = {
            zoneItems: [],
            scenarios: [],
            currentZoneItem: null,
            currentScenario: null,  // Track the currently selected scenario
            currentShape: [],
            shapes: [],
            selectedShape: null,
            selectedPoint: null,
            isDragging: false,
            dragStartPos: { x: 0, y: 0 },
            editMode: false,
            undoStack: [],
            backgroundImage: null,
            editingItemId: null,
            configLoaded: false,  // Track if config has been loaded
            
            // Color palette for auto-generating unique colors
            colorPalette: [
                '#FFFFAA', '#FFFF00', '#B2B200', '#FFA500', '#000000',
                '#FF0000', '#FF66FF', '#0000FF', '#00FF00', '#800080',
                '#008000', '#808000', '#800000', '#00FFFF', '#FFC0CB',
                '#A52A2A', '#808080', '#4B0082', '#FFD700', '#7FFFD4'
            ],
            usedColors: []
        };
        
        // DOM Elements
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const zoneContainer = document.getElementById('zone-container');
        const scenariosContainer = document.getElementById('scenarios-container');
        const uploadBgBtn = document.getElementById('upload-bg-btn');
        const downloadPngBtn = document.getElementById('download-png-btn');
        const undoBtn = document.getElementById('undo-btn');
        const editShapesBtn = document.getElementById('edit-shapes-btn');
        const addZoneBtn = document.getElementById('add-zone-btn');
        const zoneModal = document.getElementById('zone-modal');
        const modalTitle = document.getElementById('modal-title');
        const zoneNameInput = document.getElementById('zone-name');
        const zoneColorInput = document.getElementById('zone-color');
        const saveZoneBtn = document.getElementById('save-zone-btn');
        const cancelZoneBtn = document.getElementById('cancel-zone-btn');
        const modalClose = document.querySelector('.modal-close');
        // Scenario modal elements
        const addScenarioBtn = document.getElementById('add-scenario-btn');
        const scenarioModal = document.getElementById('scenario-modal');
        const scenarioModalTitle = document.getElementById('scenario-modal-title');
        const scenarioNameInput = document.getElementById('scenario-name');
        const scenarioDescriptionInput = document.getElementById('scenario-description');
        const scenarioActiveInput = document.getElementById('scenario-active');
        const saveScenarioBtn = document.getElementById('save-scenario-btn');
        const cancelScenarioBtn = document.getElementById('cancel-scenario-btn');
        const modalCloseScenario = document.querySelector('.modal-close-scenario');
        
        // Load configuration from config.json
        async function loadConfiguration() {
            try {
                // Try to load the embedded config first
                const embeddedConfig = {
                    "backgroundImage": "garbiczland.png",
                    "zones": [
                        {
                            "id": "zone_1",
                            "name": "Member 1 (Hellgelb)",
                            "color": "#FFFFAA",
                            "active": true,
                            "activeInScenarios": ["festival", "member1"]
                        },
                        {
                            "id": "zone_2",
                            "name": "Member 2 (Gelb)",
                            "color": "#FFFF00",
                            "active": true,
                            "activeInScenarios": ["festival", "member2"]
                        },
                        {
                            "id": "zone_3",
                            "name": "Member 3 (Dunkel Gelb)",
                            "color": "#B2B200",
                            "active": true,
                            "activeInScenarios": ["festival", "member3"]
                        },
                        {
                            "id": "zone_4",
                            "name": "Shareholder (Orange)",
                            "color": "#FFA500",
                            "active": true,
                            "activeInScenarios": ["festival", "all_year"]
                        },
                        {
                            "id": "zone_5",
                            "name": "Backstage (Schwarz)",
                            "color": "#000000",
                            "active": true,
                            "activeInScenarios": ["festival", "all_year", "other_events"]
                        },
                        {
                            "id": "zone_6",
                            "name": "Event (Rot)",
                            "color": "#FF0000",
                            "active": true,
                            "activeInScenarios": ["festival", "other_events"]
                        },
                        {
                            "id": "zone_7",
                            "name": "Camping (Pink)",
                            "color": "#FF66FF",
                            "active": true,
                            "activeInScenarios": ["festival"]
                        },
                        {
                            "id": "zone_8",
                            "name": "Spa (Blau)",
                            "color": "#0000FF",
                            "active": true,
                            "activeInScenarios": ["all_year"]
                        }
                    ],
                    "scenarios": [
                        {
                            "id": "festival",
                            "name": "Festival",
                            "description": "Main festival layout",
                            "active": true
                        },
                        {
                            "id": "all_year",
                            "name": "All Year",
                            "description": "Year-round access areas",
                            "active": false
                        },
                        {
                            "id": "member1",
                            "name": "Member 1",
                            "description": "Member 1 specific areas",
                            "active": false
                        },
                        {
                            "id": "member2",
                            "name": "Member 2",
                            "description": "Member 2 specific areas",
                            "active": false
                        },
                        {
                            "id": "member3",
                            "name": "Member 3",
                            "description": "Member 3 specific areas",
                            "active": false
                        },
                        {
                            "id": "other_events",
                            "name": "Other Events",
                            "description": "Layout for other events",
                            "active": false
                        }
                    ]
                };
                
                // Try to load the external config file (may fail due to CORS when running from file://)
                try {
                    const response = await fetch('config.json');
                    if (response.ok) {
                        const config = await response.json();
                        console.log('Loaded external config.json');
                        
                        // Load background image
                        if (config.backgroundImage) {
                            loadBackgroundImage(config.backgroundImage);
                        }
                        
                        // Set configLoaded flag
                        appState.configLoaded = true;
                        
                        return config;
                    }
                } catch (fetchError) {
                    console.warn('Could not load external config.json, using embedded config:', fetchError);
                }
                
                // If external config failed, use the embedded config
                console.log('Using embedded config');
                
                // Load background image
                if (embeddedConfig.backgroundImage) {
                    loadBackgroundImage(embeddedConfig.backgroundImage);
                }
                
                // Set configLoaded flag
                appState.configLoaded = true;
                
                return embeddedConfig;
            } catch (error) {
                console.error('Error loading configuration:', error);
                return null;
            }
        }
        
        // Helper function to load background image
        function loadBackgroundImage(src) {
            const img = new Image();
            img.onload = function() {
                appState.backgroundImage = img;
                canvas.width = img.width > 1000 ? 1000 : img.width;
                canvas.height = canvas.width * (img.height / img.width);
                redrawCanvas();
            };
            img.src = src;
        }
        
        // Initialize zone items from config
        function initializeDefaultZoneItems(config) {
            if (config && config.zones && config.zones.length > 0) {
                config.zones.forEach(item => {
                    const zoneItem = {
                        id: item.id || generateId(),
                        name: item.name,
                        color: item.color,
                        active: item.active !== undefined ? item.active : true,
                        activeInScenarios: item.activeInScenarios || []
                    };
                    
                    appState.zoneItems.push(zoneItem);
                    appState.usedColors.push(item.color);
                });
            } else {
                // Fallback to hardcoded defaults if config is not available
                const defaultItems = [
                    { id: generateId(), name: 'Member 1 (Hellgelb)', color: '#FFFFAA', active: true, activeInScenarios: ['festival', 'member1'] },
                    { id: generateId(), name: 'Member 2 (Gelb)', color: '#FFFF00', active: true, activeInScenarios: ['festival', 'member2'] },
                    { id: generateId(), name: 'Member 3 (Dunkel Gelb)', color: '#B2B200', active: true, activeInScenarios: ['festival', 'member3'] },
                    { id: generateId(), name: 'Shareholder (Orange)', color: '#FFA500', active: true, activeInScenarios: ['festival', 'all_year'] },
                    { id: generateId(), name: 'Backstage (Schwarz)', color: '#000000', active: true, activeInScenarios: ['festival', 'all_year', 'other_events'] },
                    { id: generateId(), name: 'Event (Rot)', color: '#FF0000', active: true, activeInScenarios: ['festival', 'other_events'] },
                    { id: generateId(), name: 'Camping (Pink)', color: '#FF66FF', active: true, activeInScenarios: ['festival'] },
                    { id: generateId(), name: 'Spa (Blau)', color: '#0000FF', active: true, activeInScenarios: ['all_year'] }
                ];
                
                defaultItems.forEach(item => {
                    appState.zoneItems.push(item);
                    appState.usedColors.push(item.color);
                });
            }
        }

        // Initialize scenarios from config
        function initializeDefaultScenarios(config) {
            if (config && config.scenarios && config.scenarios.length > 0) {
                config.scenarios.forEach(item => {
                    const scenario = {
                        id: item.id || generateId(),
                        name: item.name,
                        description: item.description || '',
                        active: item.active !== undefined ? item.active : false,
                        zones: {}
                    };
                    
                    // Initialize zones visibility
                    appState.zoneItems.forEach(zone => {
                        scenario.zones[zone.id] = {
                            visible: zone.activeInScenarios.includes(scenario.id)
                        };
                    });
                    
                    appState.scenarios.push(scenario);
                    
                    // Set the first active scenario as current
                    if (item.active && !appState.currentScenario) {
                        appState.currentScenario = scenario.id;
                    }
                });
                
                // If no scenario is active, set the first one as active
                if (!appState.currentScenario && appState.scenarios.length > 0) {
                    appState.currentScenario = appState.scenarios[0].id;
                    appState.scenarios[0].active = true;
                }
            } else {
                // Fallback to hardcoded defaults if config is not available
                const defaultScenarios = [
                    { id: 'festival', name: 'Festival', description: 'Main festival layout', active: true },
                    { id: 'all_year', name: 'All Year', description: 'Year-round access areas', active: false },
                    { id: 'member1', name: 'Member 1', description: 'Member 1 specific areas', active: false },
                    { id: 'member2', name: 'Member 2', description: 'Member 2 specific areas', active: false },
                    { id: 'member3', name: 'Member 3', description: 'Member 3 specific areas', active: false },
                    { id: 'other_events', name: 'Other Events', description: 'Layout for other events', active: false }
                ];

                defaultScenarios.forEach(scenario => {
                    const newScenario = { ...scenario, zones: {} };
                    
                    // Initialize zones visibility based on activeInScenarios
                    appState.zoneItems.forEach(zone => {
                        newScenario.zones[zone.id] = {
                            visible: zone.activeInScenarios.includes(scenario.id)
                        };
                    });
                    
                    appState.scenarios.push(newScenario);
                });
                
                // Set the first scenario as current if none is set
                if (!appState.currentScenario && appState.scenarios.length > 0) {
                    appState.currentScenario = appState.scenarios[0].id;
                }
            }
        }
        
        // Generate a unique ID
        function generateId() {
            return 'id_' + Math.random().toString(36).substr(2, 9);
        }
        
        // Get a unique color for new zone items
        function getUniqueColor() {
            const availableColors = appState.colorPalette.filter(
                color => !appState.usedColors.includes(color)
            );
            
            if (availableColors.length > 0) {
                return availableColors[0];
            } else {
                const r = Math.floor(Math.random() * 200) + 55;
                const g = Math.floor(Math.random() * 200) + 55;
                const b = Math.floor(Math.random() * 200) + 55;
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
        }
        
        // Render zone items in the sidebar
        function renderZoneItems() {
            zoneContainer.innerHTML = '';
            
            // Get current scenario
            const currentScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
            if (!currentScenario) return;
            
            // Filter zones to show only those active in the current scenario
            appState.zoneItems.forEach(item => {
                // Skip zones not active in the current scenario
                if (!item.activeInScenarios.includes(currentScenario.id)) return;
                
                const zoneItem = document.createElement('div');
                zoneItem.className = `zone-item ${appState.currentZoneItem === item.id ? 'selected' : ''} ${!item.active ? 'deactivated' : ''}`;
                zoneItem.dataset.id = item.id;
                
                const leftSide = document.createElement('div');
                leftSide.className = 'flex items-center flex-1';
                
                const colorSwatch = document.createElement('span');
                colorSwatch.className = 'color-swatch';
                colorSwatch.style.backgroundColor = item.color;
                colorSwatch.style.opacity = item.active ? '1' : '0.5';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = item.name;
                
                leftSide.appendChild(colorSwatch);
                leftSide.appendChild(nameSpan);
                
                const controls = document.createElement('div');
                controls.className = 'zone-controls';
                
                const editBtn = document.createElement('span');
                editBtn.className = 'zone-control';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.title = 'Edit';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    openEditZoneModal(item);
                };
                
                const toggleBtn = document.createElement('span');
                toggleBtn.className = 'zone-control';
                toggleBtn.innerHTML = item.active ? '<i class="fas fa-eye-slash"></i>' : '<i class="fas fa-eye"></i>';
                toggleBtn.title = item.active ? 'Deactivate' : 'Activate';
                toggleBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleZoneItem(item.id);
                };
                
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'zone-control';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteZoneItem(item.id);
                };
                
                controls.appendChild(editBtn);
                controls.appendChild(toggleBtn);
                controls.appendChild(deleteBtn);
                
                zoneItem.appendChild(leftSide);
                zoneItem.appendChild(controls);
                
                zoneItem.addEventListener('click', () => {
                    if (item.active) {
                        setCurrentZoneItem(item.id);
                    }
                });
                
                zoneContainer.appendChild(zoneItem);
            });
        }
        
        // Render scenario controls
        function renderScenarios() {
            scenariosContainer.innerHTML = '';
            
            // Create header for scenario selection
            const scenarioHeader = document.createElement('div');
            scenarioHeader.className = 'mb-4';
            scenarioHeader.innerHTML = '<p class="text-sm text-gray-600 mb-2">Select active scenario:</p>';
            scenariosContainer.appendChild(scenarioHeader);
            
            appState.scenarios.forEach(scenario => {
                const scenarioItem = document.createElement('div');
                const isActive = scenario.id === appState.currentScenario;
                
                scenarioItem.className = `scenario-item ${isActive ? 'bg-blue-100 font-semibold' : ''}`;
                scenarioItem.dataset.id = scenario.id;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = scenario.name;
                
                const controls = document.createElement('div');
                controls.className = 'flex items-center';
                
                const toggleBtn = document.createElement('button');
                toggleBtn.innerHTML = '<i class="fas fa-eye"></i>';
                toggleBtn.className = 'zone-control mr-2';
                toggleBtn.title = 'Toggle Visibility';
                toggleBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleScenarioVisibility(scenario.id);
                };

                // Edit button
                const editBtn = document.createElement('span');
                editBtn.className = 'zone-control mr-2';
                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                editBtn.title = 'Edit Scenario';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    openEditScenarioModal(scenario);
                };

                // Delete button
                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'zone-control';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Delete Scenario';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteScenario(scenario.id);
                };

                controls.appendChild(toggleBtn);
                controls.appendChild(editBtn);
                controls.appendChild(deleteBtn);

                scenarioItem.appendChild(nameSpan);
                scenarioItem.appendChild(controls);

                // Add click handler to select this scenario
                scenarioItem.addEventListener('click', () => {
                    setCurrentScenario(scenario.id);
                });

                scenariosContainer.appendChild(scenarioItem);
            });
            
            // Add description for the current scenario
            const currentScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
            if (currentScenario && currentScenario.description) {
                const descriptionEl = document.createElement('div');
                descriptionEl.className = 'mt-4 text-sm text-gray-600';
                descriptionEl.textContent = currentScenario.description;
                scenariosContainer.appendChild(descriptionEl);
            }
        }
        
        // Set current zone item for drawing
        function setCurrentZoneItem(id) {
            appState.currentZoneItem = id;
            appState.selectedShape = null;
            appState.selectedPoint = null;
            appState.editMode = false;
            renderZoneItems();
            redrawCanvas();
        }
        
        // Toggle zone item active state
        function toggleZoneItem(id) {
            const itemIndex = appState.zoneItems.findIndex(item => item.id === id);
            if (itemIndex !== -1) {
                appState.zoneItems[itemIndex].active = !appState.zoneItems[itemIndex].active;
                
                if (appState.currentZoneItem === id && !appState.zoneItems[itemIndex].active) {
                    appState.currentZoneItem = null;
                }
                
                renderZoneItems();
                redrawCanvas();
            }
        }
        
        // Delete a zone item
        function deleteZoneItem(id) {
            const confirmDelete = confirm('Are you sure you want to delete this zone item? All shapes using this item will also be deleted.');
            
            if (confirmDelete) {
                appState.zoneItems = appState.zoneItems.filter(item => item.id !== id);
                
                const itemColor = appState.zoneItems.find(item => item.id === id)?.color;
                if (itemColor) {
                    appState.usedColors = appState.usedColors.filter(color => color !== itemColor);
                }
                
                appState.shapes = appState.shapes.filter(shape => shape.zoneItemId !== id);
                
                // Update scenarios
                appState.scenarios.forEach(scenario => {
                    delete scenario.zones[id];
                });
                
                if (appState.currentZoneItem === id) {
                    appState.currentZoneItem = null;
                }
                
                renderZoneItems();
                renderScenarios();
                redrawCanvas();
            }
        }
        
        // Set current scenario
        function setCurrentScenario(id) {
            // Deactivate current scenario
            if (appState.currentScenario) {
                const oldScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
                if (oldScenario) {
                    oldScenario.active = false;
                }
            }
            
            // Activate new scenario
            const newScenario = appState.scenarios.find(s => s.id === id);
            if (newScenario) {
                newScenario.active = true;
                appState.currentScenario = id;
                
                // Update UI
                renderScenarios();
                renderZoneItems(); // Re-render zones to show only those active in this scenario
                redrawCanvas();
            }
        }
        
        // Toggle scenario visibility
        function toggleScenarioVisibility(id) {
            const scenario = appState.scenarios.find(s => s.id === id);
            if (scenario) {
                // Toggle visibility of all zones in this scenario
                for (const zoneId in scenario.zones) {
                    scenario.zones[zoneId].visible = !scenario.zones[zoneId].visible;
                }
                redrawCanvas();
            }
        }
        
        // Open modal to add a new zone item
        function openAddZoneModal() {
            modalTitle.textContent = 'Add Zone Item';
            zoneNameInput.value = '';
            zoneColorInput.value = getUniqueColor();
            appState.editingItemId = null;
            
            // Populate scenario checkboxes
            populateScenarioCheckboxes([]);
            
            zoneModal.style.display = 'flex';
        }
        // Open modal to edit an existing zone item
        function openEditZoneModal(item) {
            modalTitle.textContent = 'Edit Zone Item';
            zoneNameInput.value = item.name;
            zoneColorInput.value = item.color;
            appState.editingItemId = item.id;
            
            // Populate scenario checkboxes with selected scenarios
            populateScenarioCheckboxes(item.activeInScenarios || []);
            
            zoneModal.style.display = 'flex';
        }
        
        // Populate scenario checkboxes in the zone modal
        function populateScenarioCheckboxes(selectedScenarios) {
            const checkboxContainer = document.getElementById('scenario-checkboxes');
            checkboxContainer.innerHTML = '';
            
            appState.scenarios.forEach(scenario => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'flex items-center';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `scenario-${scenario.id}`;
                checkbox.className = 'mr-2';
                checkbox.checked = selectedScenarios.includes(scenario.id);
                checkbox.value = scenario.id;
                
                const label = document.createElement('label');
                label.htmlFor = `scenario-${scenario.id}`;
                label.textContent = scenario.name;
                label.className = 'text-sm';
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                checkboxContainer.appendChild(checkboxDiv);
            });
        }
        
        // Close the zone modal
        function closeZoneModal() {
            zoneModal.style.display = 'none';
        }
        
        // Save a new or edited zone item
        function saveZoneItem() {
            const name = zoneNameInput.value.trim();
            let color = zoneColorInput.value;
            
            if (!name) {
                alert('Please enter a name for the zone item.');
                return;
            }
            
            // Get selected scenarios
            const selectedScenarios = [];
            const checkboxes = document.querySelectorAll('#scenario-checkboxes input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedScenarios.push(checkbox.value);
                }
            });
            
            if (selectedScenarios.length === 0) {
                alert('Please select at least one scenario for this zone.');
                return;
            }
            
            if (appState.editingItemId) {
                const itemIndex = appState.zoneItems.findIndex(item => item.id === appState.editingItemId);
                
                if (itemIndex !== -1) {
                    const oldColor = appState.zoneItems[itemIndex].color;
                    if (oldColor !== color) {
                        const colorInUse = appState.zoneItems.some(item =>
                            item.id !== appState.editingItemId && item.color === color
                        );
                        
                        if (colorInUse) {
                            color = getUniqueColor();
                        }
                        
                        appState.usedColors = appState.usedColors.filter(c => c !== oldColor);
                        appState.usedColors.push(color);
                    }
                    
                    appState.zoneItems[itemIndex].name = name;
                    appState.zoneItems[itemIndex].color = color;
                    appState.zoneItems[itemIndex].activeInScenarios = selectedScenarios;
                    
                    // Update shapes with this zone item
                    appState.shapes.forEach(shape => {
                        if (shape.zoneItemId === appState.editingItemId) {
                            shape.color = color;
                        }
                    });
                    
                    // Update scenario zones
                    appState.scenarios.forEach(scenario => {
                        scenario.zones[appState.editingItemId] = {
                            visible: selectedScenarios.includes(scenario.id)
                        };
                    });
                }
            } else {
                const colorInUse = appState.zoneItems.some(item => item.color === color);
                if (colorInUse) {
                    color = getUniqueColor();
                }
                
                const newItem = {
                    id: generateId(),
                    name: name,
                    color: color,
                    active: true,
                    activeInScenarios: selectedScenarios
                };
                
                appState.zoneItems.push(newItem);
                appState.usedColors.push(color);
                
                // Add to scenarios
                appState.scenarios.forEach(scenario => {
                    scenario.zones[newItem.id] = {
                        visible: selectedScenarios.includes(scenario.id)
                    };
                });
            }
            
            renderZoneItems();
            renderScenarios();
            closeZoneModal();
            redrawCanvas();
        }
        
        // Toggle edit mode
        function toggleEditMode() {
            appState.editMode = !appState.editMode;
            appState.selectedShape = null;
            appState.selectedPoint = null;
            
            if (appState.editMode) {
                canvas.style.cursor = 'pointer';
                editShapesBtn.innerHTML = '<i class="fas fa-draw-polygon"></i> Draw Mode';
            } else {
                canvas.style.cursor = 'crosshair';
                editShapesBtn.innerHTML = '<i class="fas fa-edit"></i> Edit Shapes';
            }
            
            redrawCanvas();
        }
        
        // Check if a point is inside a shape
        function isPointInShape(x, y, shape) {
            let inside = false;
            const points = shape.points;
            
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x, yi = points[i].y;
                const xj = points[j].x, yj = points[j].y;
                
                const intersect = ((yi > y) !== (yj > y)) && 
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }
        
        // Find the closest point on a line segment from a given point
        function closestPointOnLine(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = x - xx;
            const dy = y - yy;
            
            return {
                x: xx,
                y: yy,
                distance: Math.sqrt(dx * dx + dy * dy),
                param: param
            };
        }
        
        // Find the closest point and line segment to the cursor
        function findClosestPointAndLine(x, y) {
            const threshold = 10; // distance threshold for selection
            let closestPoint = null;
            let closestDistance = Infinity;
            let closestShape = null;
            let closestPointIndex = -1;
            
            let closestLinePoint = null;
            let closestLineDistance = Infinity;
            let closestLineShape = null;
            let closestLineIndex = -1;
            
            appState.shapes.forEach((shape, shapeIndex) => {
                // Skip shapes that are from inactive zone items
                const zoneItem = appState.zoneItems.find(item => item.id === shape.zoneItemId);
                if (!zoneItem || !zoneItem.active) return;
                
                // Check if any points are close to the cursor
                shape.points.forEach((point, pointIndex) => {
                    const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                    if (distance < threshold && distance < closestDistance) {
                        closestDistance = distance;
                        closestPoint = point;
                        closestShape = shape;
                        closestPointIndex = pointIndex;
                    }
                });
                
                // Check if cursor is close to any line segments
                for (let i = 0; i < shape.points.length; i++) {
                    const p1 = shape.points[i];
                    const p2 = shape.points[(i + 1) % shape.points.length];
                    
                    const closest = closestPointOnLine(x, y, p1.x, p1.y, p2.x, p2.y);
                    
                    if (closest.distance < threshold && closest.distance < closestLineDistance) {
                        closestLineDistance = closest.distance;
                        closestLinePoint = closest;
                        closestLineShape = shape;
                        closestLineIndex = i;
                    }
                }
            });
            
            // If we found a point, return that
            if (closestPoint) {
                return {
                    type: 'point',
                    point: closestPoint,
                    shape: closestShape,
                    index: closestPointIndex,
                    distance: closestDistance
                };
            }
            
            // Otherwise, if we found a line, return that
            if (closestLinePoint) {
                return {
                    type: 'line',
                    point: closestLinePoint,
                    shape: closestLineShape,
                    index: closestLineIndex,
                    distance: closestLineDistance
                };
            }
            
            return null;
        }
        
        // Handle mouse down event
        function handleMouseDown(e) {
            if (e.button === 2) return; // Handle right-click separately
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (appState.editMode) {
                // In edit mode, check if we clicked on a shape or point
                const closest = findClosestPointAndLine(x, y);
                
                if (closest && closest.type === 'point') {
                    // We clicked on a point, select it for dragging
                    appState.selectedShape = closest.shape;
                    appState.selectedPoint = closest.index;
                    appState.isDragging = true;
                    appState.dragStartPos = { x, y };
                    redrawCanvas();
                    return;
                }
                
                // Check if we clicked inside a shape
                for (let i = appState.shapes.length - 1; i >= 0; i--) {
                    const shape = appState.shapes[i];
                    const zoneItem = appState.zoneItems.find(item => item.id === shape.zoneItemId);
                    
                    if (!zoneItem || !zoneItem.active) continue;
                    
                    if (isPointInShape(x, y, shape)) {
                        appState.selectedShape = shape;
                        appState.isDragging = true;
                        appState.dragStartPos = { x, y };
                        redrawCanvas();
                        return;
                    }
                }
                
                appState.selectedShape = null;
                appState.selectedPoint = null;
                redrawCanvas();
            } else {
                // In draw mode, add points to the current shape
                if (!appState.currentZoneItem) {
                    alert('Please select a zone item before drawing.');
                    return;
                }
                
                appState.currentShape.push({ x, y });
                
                const action = {
                    type: 'add_point',
                    point: { x, y },
                    shapeIndex: appState.currentShape.length - 1
                };
                appState.undoStack.push(action);
                
                redrawCanvas();
            }
        }
        
        // Handle mouse move event
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (appState.editMode && appState.isDragging) {
                const deltaX = x - appState.dragStartPos.x;
                const deltaY = y - appState.dragStartPos.y;
                
                if (appState.selectedShape) {
                    if (appState.selectedPoint !== null) {
                        // Dragging a single point
                        appState.selectedShape.points[appState.selectedPoint].x += deltaX;
                        appState.selectedShape.points[appState.selectedPoint].y += deltaY;
                    } else {
                        // Dragging the entire shape
                        appState.selectedShape.points.forEach(point => {
                            point.x += deltaX;
                            point.y += deltaY;
                        });
                    }
                    
                    appState.dragStartPos = { x, y };
                    redrawCanvas();
                }
            }
        }
        
        // Handle mouse up event
        function handleMouseUp(e) {
            if (appState.editMode && appState.isDragging) {
                appState.isDragging = false;
                
                // Save the move action for undo
                if (appState.selectedShape) {
                    const action = {
                        type: 'move_shape',
                        shape: JSON.parse(JSON.stringify(appState.selectedShape)),
                        shapeIndex: appState.shapes.indexOf(appState.selectedShape)
                    };
                    appState.undoStack.push(action);
                }
            }
        }
        
        // Handle right-click event
        function handleContextMenu(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (appState.editMode) {
                // In edit mode, right-click to add or remove points
                const closest = findClosestPointAndLine(x, y);
                
                if (closest) {
                    if (closest.type === 'point') {
                        // Remove the point if it's not the only point
                        if (closest.shape.points.length > 3) {
                            closest.shape.points.splice(closest.index, 1);
                            
                            const action = {
                                type: 'remove_point',
                                shape: closest.shape,
                                pointIndex: closest.index,
                                point: closest.point
                            };
                            appState.undoStack.push(action);
                            
                            redrawCanvas();
                        }
                    } else if (closest.type === 'line') {
                        // Add a new point on the line
                        const newPoint = {
                            x: closest.point.x,
                            y: closest.point.y
                        };
                        
                        closest.shape.points.splice(closest.index + 1, 0, newPoint);
                        
                        const action = {
                            type: 'add_shape_point',
                            shape: closest.shape,
                            pointIndex: closest.index + 1,
                            point: newPoint
                        };
                        appState.undoStack.push(action);
                        
                        redrawCanvas();
                    }
                }
            } else {
                // In draw mode, right-click to remove the last point
                if (appState.currentShape.length > 0) {
                    appState.currentShape.pop();
                    
                    const action = {
                        type: 'remove_current_point'
                    };
                    appState.undoStack.push(action);
                    
                    redrawCanvas();
                }
            }
        }
        
        // Handle keyboard events
        function handleKeyDown(e) {
            // Enter key to complete the shape
            if (e.key === 'Enter' && appState.currentShape.length >= 3) {
                completeCurrentShape();
            }
            
            // Undo (Ctrl+Z or Cmd+Z)
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undoLastAction();
            }
            
            // Delete key to delete selected shape
            if (e.key === 'Delete' && appState.selectedShape) {
                const shapeIndex = appState.shapes.indexOf(appState.selectedShape);
                if (shapeIndex !== -1) {
                    const action = {
                        type: 'delete_shape',
                        shape: appState.selectedShape,
                        shapeIndex: shapeIndex
                    };
                    appState.undoStack.push(action);
                    
                    appState.shapes.splice(shapeIndex, 1);
                    appState.selectedShape = null;
                    redrawCanvas();
                }
            }
        }
        
        // Complete the current shape being drawn
        function completeCurrentShape() {
            if (appState.currentShape.length >= 3 && appState.currentZoneItem) {
                const zoneItem = appState.zoneItems.find(item => item.id === appState.currentZoneItem);
                
                if (zoneItem) {
                    const shape = {
                        zoneItemId: zoneItem.id,
                        color: zoneItem.color,
                        points: [...appState.currentShape]
                    };
                    
                    appState.shapes.push(shape);
                    
                    const action = {
                        type: 'complete_shape',
                        shape: shape,
                        shapeIndex: appState.shapes.length - 1
                    };
                    appState.undoStack.push(action);
                    
                    appState.currentShape = [];
                    redrawCanvas();
                }
            }
        }
        
        // Undo the last action
        function undoLastAction() {
            if (appState.undoStack.length > 0) {
                const lastAction = appState.undoStack.pop();
                
                switch (lastAction.type) {
                    case 'add_point':
                        if (appState.currentShape.length > 0) {
                            appState.currentShape.pop();
                        }
                        break;
                        
                    case 'remove_current_point':
                        if (lastAction.point) {
                            appState.currentShape.push(lastAction.point);
                        }
                        break;
                        
                    case 'complete_shape':
                        if (lastAction.shapeIndex !== undefined) {
                            appState.shapes.splice(lastAction.shapeIndex, 1);
                        }
                        break;
                        
                    case 'move_shape':
                        if (lastAction.shape && lastAction.shapeIndex !== undefined) {
                            appState.shapes[lastAction.shapeIndex] = JSON.parse(JSON.stringify(lastAction.shape));
                        }
                        break;
                        
                    case 'delete_shape':
                        if (lastAction.shape) {
                            appState.shapes.splice(lastAction.shapeIndex, 0, lastAction.shape);
                        }
                        break;
                        
                    case 'add_shape_point':
                        if (lastAction.shape && lastAction.pointIndex !== undefined) {
                            lastAction.shape.points.splice(lastAction.pointIndex, 1);
                        }
                        break;
                        
                    case 'remove_point':
                        if (lastAction.shape && lastAction.pointIndex !== undefined && lastAction.point) {
                            lastAction.shape.points.splice(lastAction.pointIndex, 0, lastAction.point);
                        }
                        break;
                }
                
                redrawCanvas();
            }
        }
        
        // Handle file selection for background upload
        function handleBackgroundUpload(e) {
            const file = e.target.files[0];
            if (file && file.type.match('image.*')) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        appState.backgroundImage = img;
                        
                        // Resize canvas to match image aspect ratio
                        const aspectRatio = img.width / img.height;
                        const canvasWidth = Math.min(img.width, 1000);
                        const canvasHeight = canvasWidth / aspectRatio;
                        
                        canvas.width = canvasWidth;
                        canvas.height = canvasHeight;
                        
                        redrawCanvas();
                    };
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // Download the canvas as PNG
        function downloadCanvasAsPNG() {
            const link = document.createElement('a');
            link.download = 'garbiczland-plan.png';
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Redraw the entire canvas
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background image if available
            if (appState.backgroundImage) {
                ctx.drawImage(appState.backgroundImage, 0, 0, canvas.width, canvas.height);
            }
            
            // Get visible shapes based on scenarios
            const visibleZoneIds = {};
            
            // First, mark all zones as not visible
            appState.zoneItems.forEach(item => {
                visibleZoneIds[item.id] = false;
            });
            
            // Then, make zones visible if they are active and in the current scenario
            const currentScenario = appState.scenarios.find(s => s.id === appState.currentScenario);
            if (currentScenario) {
                appState.zoneItems.forEach(item => {
                    // Check if zone is active and in the current scenario
                    if (item.active && item.activeInScenarios.includes(currentScenario.id)) {
                        visibleZoneIds[item.id] = true;
                    }
                });
                
                // Apply scenario visibility settings
                for (const zoneId in currentScenario.zones) {
                    if (!currentScenario.zones[zoneId].visible) {
                        visibleZoneIds[zoneId] = false;
                    }
                }
            }
            
            // Draw all completed shapes
            appState.shapes.forEach(shape => {
                if (visibleZoneIds[shape.zoneItemId]) {
                    const isSelected = shape === appState.selectedShape;
                    drawShape(shape.points, shape.color, 0.5, isSelected);
                }
            });
            
            // Draw current shape being created
            if (appState.currentShape.length > 0) {
                const zoneItem = appState.zoneItems.find(item => item.id === appState.currentZoneItem);
                if (zoneItem) {
                    drawShape(appState.currentShape, zoneItem.color, 0.5, false);
                    
                    // Draw points for current shape
                    appState.currentShape.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        ctx.fillStyle = zoneItem.color;
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });
                }
            }
            
            // In edit mode, draw handles for the selected shape
            if (appState.editMode && appState.selectedShape) {
                appState.selectedShape.points.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = index === appState.selectedPoint ? '#ff0000' : '#ffffff';
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
        }
        
        // Draw a shape on the canvas
        function drawShape(points, color, opacity, isSelected) {
            if (points.length < 3) return;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.closePath();
            
            // Fill with semi-transparent color
            const alpha = Math.floor(opacity * 255).toString(16).padStart(2, '0');
            ctx.fillStyle = color + alpha;
            ctx.fill();
            
            // Draw outline
            ctx.strokeStyle = isSelected ? '#ff0000' : color;
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.stroke();
        }
        
        // --- Scenario Modal Logic ---

        // Track which scenario is being edited (null for add)
        appState.editingScenarioId = null;

        function openAddScenarioModal() {
            scenarioModalTitle.textContent = 'Add Scenario';
            scenarioNameInput.value = '';
            scenarioDescriptionInput.value = '';
            scenarioActiveInput.checked = false;
            appState.editingScenarioId = null;
            scenarioModal.style.display = 'flex';
        }

        function openEditScenarioModal(scenario) {
            scenarioModalTitle.textContent = 'Edit Scenario';
            scenarioNameInput.value = scenario.name;
            scenarioDescriptionInput.value = scenario.description || '';
            scenarioActiveInput.checked = !!scenario.active;
            appState.editingScenarioId = scenario.id;
            scenarioModal.style.display = 'flex';
        }

        function closeScenarioModal() {
            scenarioModal.style.display = 'none';
        }

        function saveScenario() {
            const name = scenarioNameInput.value.trim();
            const description = scenarioDescriptionInput.value.trim();
            const isActive = scenarioActiveInput.checked;

            if (!name) {
                alert('Please enter a name for the scenario.');
                return;
            }

            // If editing, update existing scenario
            if (appState.editingScenarioId) {
                const idx = appState.scenarios.findIndex(s => s.id === appState.editingScenarioId);
                if (idx !== -1) {
                    appState.scenarios[idx].name = name;
                    appState.scenarios[idx].description = description;
                    // If set as active, deactivate others
                    if (isActive) {
                        appState.scenarios.forEach(s => s.active = false);
                        appState.scenarios[idx].active = true;
                        appState.currentScenario = appState.scenarios[idx].id;
                    }
                }
            } else {
                // Generate unique id
                let newId = name.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                if (appState.scenarios.some(s => s.id === newId)) {
                    newId = generateId();
                }
                // Add new scenario
                const newScenario = {
                    id: newId,
                    name,
                    description,
                    active: isActive,
                    zones: {}
                };
                // Initialize zones visibility
                appState.zoneItems.forEach(zone => {
                    newScenario.zones[zone.id] = {
                        visible: zone.activeInScenarios.includes(newScenario.id)
                    };
                });
                if (isActive) {
                    appState.scenarios.forEach(s => s.active = false);
                    appState.currentScenario = newScenario.id;
                }
                appState.scenarios.push(newScenario);
            }

            // If set as active, ensure only one is active
            if (isActive) {
                appState.scenarios.forEach(s => {
                    if (s.id !== (appState.editingScenarioId || (appState.scenarios[appState.scenarios.length - 1]?.id))) {
                        s.active = false;
                    }
                });
            }

            renderScenarios();
            renderZoneItems();
            closeScenarioModal();
            redrawCanvas();
        }

        function deleteScenario(id) {
            // Prevent deleting the last scenario
            if (appState.scenarios.length <= 1) {
                alert('At least one scenario must exist.');
                return;
            }
            // Prevent deleting if any zone would have no scenario
            const zonesWithOnlyThisScenario = appState.zoneItems.filter(zone =>
                zone.activeInScenarios.length === 1 && zone.activeInScenarios[0] === id
            );
            if (zonesWithOnlyThisScenario.length > 0) {
                alert('Cannot delete this scenario because some zones are only active in this scenario.');
                return;
            }
            if (!confirm('Are you sure you want to delete this scenario?')) return;
            // Remove scenario from appState
            appState.scenarios = appState.scenarios.filter(s => s.id !== id);
            // Remove from all zoneItems' activeInScenarios
            appState.zoneItems.forEach(zone => {
                zone.activeInScenarios = zone.activeInScenarios.filter(sid => sid !== id);
            });
            // Remove from all scenario.zones
            appState.scenarios.forEach(scenario => {
                for (const zoneId in scenario.zones) {
                    if (scenario.zones[zoneId] && scenario.zones[zoneId].visible && !appState.zoneItems.find(z => z.id === zoneId)) {
                        delete scenario.zones[zoneId];
                    }
                }
            });
            // If deleted scenario was active, set another as active
            if (appState.currentScenario === id) {
                if (appState.scenarios.length > 0) {
                    appState.currentScenario = appState.scenarios[0].id;
                    appState.scenarios[0].active = true;
                } else {
                    appState.currentScenario = null;
                }
            }
            renderScenarios();
            renderZoneItems();
            redrawCanvas();
        }

        // --- End Scenario Modal Logic ---

        // Initialize application
        async function initApp() {
            // Set up canvas and initial state
            canvas.width = 1000;
            canvas.height = 800;
            
            // Load configuration
            const config = await loadConfiguration();
            
            // Initialize default data
            initializeDefaultZoneItems(config);
            initializeDefaultScenarios(config);
            
            // Render UI components
            renderZoneItems();
            renderScenarios();
            
            // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', handleContextMenu);
            
            // Set up event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('keydown', handleKeyDown);
            
            uploadBgBtn.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = handleBackgroundUpload;
                input.click();
            });
            
            downloadPngBtn.addEventListener('click', downloadCanvasAsPNG);
            undoBtn.addEventListener('click', undoLastAction);
            editShapesBtn.addEventListener('click', toggleEditMode);
            addZoneBtn.addEventListener('click', openAddZoneModal);
            
            saveZoneBtn.addEventListener('click', saveZoneItem);
            cancelZoneBtn.addEventListener('click', closeZoneModal);
            modalClose.addEventListener('click', closeZoneModal);

            // Scenario modal event listeners
            addScenarioBtn.addEventListener('click', openAddScenarioModal);
            saveScenarioBtn.addEventListener('click', saveScenario);
            cancelScenarioBtn.addEventListener('click', closeScenarioModal);
            modalCloseScenario.addEventListener('click', closeScenarioModal);

            // Set up touch events for mobile
            let touchStartX = 0;
            document.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
            });
            
            document.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].clientX;
                const swipeDistance = touchStartX - touchEndX;
                
                if (swipeDistance > 100) {
                    undoLastAction();
                }
            });
            
            // Load data from localStorage if available
            const savedData = localStorage.getItem('garbiczlandData');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    
                    if (parsedData.zoneItems && parsedData.zoneItems.length > 0) {
                        // Add activeInScenarios if missing
                        parsedData.zoneItems.forEach(item => {
                            if (!item.activeInScenarios) {
                                item.activeInScenarios = [];
                                // Default to all scenarios if not specified
                                appState.scenarios.forEach(scenario => {
                                    if (scenario.zones[item.id]?.visible) {
                                        item.activeInScenarios.push(scenario.id);
                                    }
                                });
                            }
                        });
                        
                        appState.zoneItems = parsedData.zoneItems;
                    }
                    
                    if (parsedData.scenarios && parsedData.scenarios.length > 0) {
                        // Add active property if missing
                        parsedData.scenarios.forEach(scenario => {
                            if (scenario.active === undefined) {
                                scenario.active = false;
                            }
                        });
                        
                        appState.scenarios = parsedData.scenarios;
                        
                        // Set current scenario
                        const activeScenario = appState.scenarios.find(s => s.active);
                        if (activeScenario) {
                            appState.currentScenario = activeScenario.id;
                        } else if (appState.scenarios.length > 0) {
                            appState.currentScenario = appState.scenarios[0].id;
                            appState.scenarios[0].active = true;
                        }
                    }
                    
                    if (parsedData.shapes) {
                        appState.shapes = parsedData.shapes;
                    }
                    
                    if (parsedData.usedColors) {
                        appState.usedColors = parsedData.usedColors;
                    }
                    
                    if (parsedData.currentScenario) {
                        appState.currentScenario = parsedData.currentScenario;
                    }
                    
                    if (parsedData.backgroundImageUrl) {
                        const img = new Image();
                        img.onload = function() {
                            appState.backgroundImage = img;
                            canvas.width = img.width > 1000 ? 1000 : img.width;
                            canvas.height = canvas.width * (img.height / img.width);
                            redrawCanvas();
                        };
                        img.src = parsedData.backgroundImageUrl;
                    }
                    
                    renderZoneItems();
                    renderScenarios();
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
            }
            
            // Draw initial canvas
            redrawCanvas();
            
            // Set up auto-save
            setInterval(() => {
                const dataToSave = {
                    zoneItems: appState.zoneItems,
                    scenarios: appState.scenarios,
                    shapes: appState.shapes,
                    usedColors: appState.usedColors,
                    currentScenario: appState.currentScenario,
                    backgroundImageUrl: appState.backgroundImage ? appState.backgroundImage.src : null
                };
                
                localStorage.setItem('garbiczlandData', JSON.stringify(dataToSave));
            }, 10000); // Auto-save every 10 seconds
        }
        
        // Initialize the application when the document is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initApp().catch(error => {
                console.error('Error initializing app:', error);
            });
        });
    </script>
</body>
</html>

